/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var score_parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,18],$V1=[1,19],$V2=[1,16],$V3=[1,17],$V4=[1,14],$V5=[1,4,11,12,20,21,42],$V6=[1,24],$V7=[1,25],$V8=[1,26],$V9=[4,14,15,16],$Va=[1,36],$Vb=[1,37],$Vc=[1,38],$Vd=[1,39],$Ve=[1,40],$Vf=[1,41],$Vg=[1,42],$Vh=[4,11,12,14,15,16,46],$Vi=[4,14,15,16,23,25,27,29,34,35,36,37,38,39,40],$Vj=[11,12,34,35,36,37,38,39,40,44],$Vk=[4,11,12,14,15,16,34,35,36,37,38,39,40,46],$Vl=[4,11,12,14,15,16,23,24,25,27,29,34,35,36,37,38,39,40,46,47],$Vm=[4,11,12,14,15,16,23,25,27,29,34,35,36,37,38,39,40,44,46];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"e":3,"EOF":4,"M":5,"Measure":6,"melody":7,"harmony":8,"percussion":9,"NUMBER":10,"DIGIT":11,"DIGITS":12,"M_end":13,"M_SEP":14,"BAR":15,"REPEAT_END":16,"Note":17,"Ctrl":18,"C0":19,"CTRL_START":20,"REPEAT_START":21,"C1":22,"t":23,"/":24,"k":25,"KEY":26,"Op_string":27,"STRING":28,"Op_unary":29,"P1":30,"C":31,"Chord":32,"P":33,"#":34,"FLAT":35,"+":36,"-":37,"NATURAL":38,"TRILL_UP":39,"TRILL_DOWN":40,"Pitches":41,"CHORD_START":42,"Inverse":43,"i":44,"DUR":45,",":46,"^":47,"$accept":0,"$end":1},
terminals_: {2:"error",4:"EOF",7:"melody",8:"harmony",9:"percussion",11:"DIGIT",12:"DIGITS",14:"M_SEP",15:"BAR",16:"REPEAT_END",20:"CTRL_START",21:"REPEAT_START",23:"t",24:"/",25:"k",26:"KEY",27:"Op_string",28:"STRING",29:"Op_unary",34:"#",35:"FLAT",36:"+",37:"-",38:"NATURAL",39:"TRILL_UP",40:"TRILL_DOWN",42:"CHORD_START",44:"i",46:",",47:"^"},
productions_: [0,[3,2],[3,3],[3,2],[3,1],[3,1],[3,1],[3,1],[10,1],[10,1],[6,2],[6,3],[13,1],[13,1],[5,1],[5,1],[5,3],[5,3],[19,1],[19,1],[22,4],[22,2],[22,2],[22,2],[22,1],[31,1],[31,2],[18,1],[18,1],[33,1],[33,2],[30,1],[30,1],[30,1],[30,1],[30,1],[30,1],[30,1],[41,1],[41,2],[32,3],[43,2],[43,2],[43,0],[17,2],[45,2],[45,3],[45,2],[45,0]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

    this.$ = $$[$0-1];
    return this.$;
  
break;
case 2:

    $$[$0-1].push({
      ctrl: 'normal_end'
    });
    $$[$0-2].data.push($$[$0-1]);
    this.$ = $$[$0-2];
    return this.$;
  
break;
case 3:

    /* push new measure */
    $$[$0-1].data.push($$[$0])
    this.$ = $$[$0-1]
  
break;
case 4:

    /* default as melody */
    this.$ = {
      mode:'melody',
      data: [$$[$0]]
      };
  
break;
case 5:

    /* create new track*/
    this.$ = {mode:'melody'};
  
break;
case 6:

    this.$ = {mode:'harmony'};
  
break;
case 7:

    this.$ = {mode:'percussion'};
  
break;
case 8:

    this.$ = parseInt($$[$0]);
  
break;
case 9:
 /* remove brackets */
    this.$ = parseInt($$[$0].substr(1,$$[$0].length-2));
    console.log('braket number', this.$);
  
break;
case 10: case 39:

    $$[$0-1].push($$[$0]);
    this.$ = $$[$0-1];
  
break;
case 11: case 16: case 17:

    $$[$0-2].push($$[$0]);
    this.$ = $$[$0-2];
  
break;
case 12:

    this.$ = {
      ctrl: 'normal_end'
    };
  
break;
case 13:

    this.$ = {
      ctrl: 'repeat_end'
    };
  
break;
case 14: case 15: case 38:

    this.$ = [$$[$0]];
  
break;
case 18:

    this.$ = ['ctrl', 'reset'];
  
break;
case 19:

    this.$ = ['ctrl', 'repeat_start'];
  
break;
case 20:

    this.$ = [$$[$0-3], [$$[$0-2], $$[$0]]];
  
break;
case 21:

    this.$ = [$$[$0-1], $$[$0]];
  
break;
case 22:

    this.$ = [$$[$0-1], $$[$0].substr(1, $$[$0].length-2)];
  
break;
case 23:

    this.$ = [$$[$0-1][0], $$[$0]];
  
break;
case 24:

    this.$ = ['p', $$[$0]];
  
break;
case 25:

    this.$ = {};
    this.$[$$[$0][0]] = $$[$0][1];
  
break;
case 26:

    $$[$0-1][$$[$0][0]] = $$[$0][1];
    if($$[$0-1].ctrl == 'reset'){
      $$[$0-1].ctrl = 'normal';
    }
    this.$ = $$[$0-1];
  
break;
case 27: case 28: case 29:

    this.$ = $$[$0];
  
break;
case 30:

    if(typeof $$[$0-1] == 'number'){
      $$[$0-1] = {
        original: $$[$0-1],
        ornament: [$$[$0]]
      };
    }else{
      $$[$0-1].ornament.push($$[$0]);
    }
    this.$ = $$[$0-1]
  
break;
case 31:

    this.$ = 1;
  
break;
case 32:

    this.$ = -1;
  
break;
case 33:

    this.$ = 12;
  
break;
case 34:

    this.$ = -12;
  
break;
case 35:

    this.$ = 0;
  
break;
case 36:

    this.$ = 'trill_up'
  
break;
case 37:

    this.$ = 'trill_down'
  
break;
case 40:

    this.$ = {};
    this.$.ctrl = 'chord';
    this.$.transpose = $$[$0-1].transpose;
    this.$.inv = $$[$0-1].inv;
    this.$.pitch = $$[$0];
  
break;
case 41:

    $$[$0-1].inv += 1;
    this.$ = $$[$0-1];
  
break;
case 42:

    if(typeof $$[$0] == 'number'){
      $$[$0-1].transpose += $$[$0];
    }else{
      // other ornament
    }

    this.$ = $$[$0-1];
  
break;
case 43:

    this.$ = {inv: 0, transpose: 0};
  
break;
case 44:

    this.$ = {
      pitch:$$[$0-1],
      dur: $$[$0]
      };
  
break;
case 45:

    this.$ = $$[$0];

  
break;
case 46:

    this.$ = {
      original: $$[$0-1],
      ornament: 'tie'
    	}
  
break;
case 47:

    this.$ = {
      original: 1,
      ornament: 'tie'
    }
  
break;
case 48:
 this.$ = 1
break;
}
},
table: [{3:1,5:6,6:2,7:[1,3],8:[1,4],9:[1,5],10:15,11:$V0,12:$V1,17:7,18:8,19:13,20:$V2,21:$V3,31:10,32:11,33:12,41:9,42:$V4},{1:[3],4:[1,20],5:21,6:22,10:15,11:$V0,12:$V1,17:7,18:8,19:13,20:$V2,21:$V3,31:10,32:11,33:12,41:9,42:$V4},o($V5,[2,4]),o($V5,[2,5]),o($V5,[2,6]),o($V5,[2,7]),{13:23,14:$V6,15:$V7,16:$V8},o($V9,[2,14]),o($V9,[2,15]),o($V9,[2,48],{10:15,45:27,33:28,11:$V0,12:$V1,46:[1,29]}),o($V9,[2,27],{22:30,30:35,23:[1,31],25:[1,32],27:[1,33],29:[1,34],34:$Va,35:$Vb,36:$Vc,37:$Vd,38:$Ve,39:$Vf,40:$Vg}),o($V9,[2,28]),o($Vh,[2,38],{30:43,34:$Va,35:$Vb,36:$Vc,37:$Vd,38:$Ve,39:$Vf,40:$Vg}),o($Vi,[2,25]),o($Vj,[2,43],{43:44}),o($Vk,[2,29]),o($Vi,[2,18]),o($Vi,[2,19]),o($Vl,[2,8]),o($Vl,[2,9]),o($V5,[2,1]),{4:[1,45],13:23,14:$V6,15:$V7,16:$V8},o($V5,[2,3]),o($V5,[2,10]),{10:15,11:$V0,12:$V1,13:46,15:$V7,16:$V8,17:47,18:48,19:13,20:$V2,21:$V3,31:10,32:11,33:12,41:9,42:$V4},o($V5,[2,12]),o($V5,[2,13]),o($V9,[2,44]),o($Vh,[2,39],{30:43,34:$Va,35:$Vb,36:$Vc,37:$Vd,38:$Ve,39:$Vf,40:$Vg}),{10:49,11:$V0,12:$V1,47:[1,50]},o($Vi,[2,26]),{10:51,11:$V0,12:$V1},{26:[1,52]},{28:[1,53]},{10:54,11:$V0,12:$V1},o($Vi,[2,24]),o($Vm,[2,31]),o($Vm,[2,32]),o($Vm,[2,33]),o($Vm,[2,34]),o($Vm,[2,35]),o($Vm,[2,36]),o($Vm,[2,37]),o($Vk,[2,30]),{10:15,11:$V0,12:$V1,30:57,33:12,34:$Va,35:$Vb,36:$Vc,37:$Vd,38:$Ve,39:$Vf,40:$Vg,41:55,44:[1,56]},o($V5,[2,2]),o($V5,[2,11]),o($V9,[2,16]),o($V9,[2,17]),o($V9,[2,45],{47:[1,58]}),o($V9,[2,47]),{24:[1,59]},o($Vi,[2,21]),o($Vi,[2,22]),o($Vi,[2,23]),o($V9,[2,40],{10:15,33:28,11:$V0,12:$V1}),o($Vj,[2,41]),o($Vj,[2,42]),o($V9,[2,46]),{10:60,11:$V0,12:$V1},o($Vi,[2,20])],
defaultActions: {},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

	
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return yy_.yytext;
break;
case 1:this.begin('NOTE'); return 11;
break;
case 2:this.begin('INITIAL'); return 15;
break;
case 3:this.begin('CTRL'); return 21;
break;
case 4:this.begin('INITIAL'); return 15;
break;
case 5:this.begin('INITIAL'); return 16;
break;
case 6:this.begin('CTRL'); return 20;
break;
case 7:this.begin('CHORD'); return 42;
break;
case 8:return 26;
break;
case 9:this.begin('NOTE'); return 14;
break;
case 10:/* skip */
break;
case 11:/* skip */
break;
case 12:return yy_.yytext[0];
break;
case 13:return 29;
break;
case 14:return 27;
break;
case 15:return 11;
break;
case 16:return 28;
break;
case 17:return 44;
break;
case 18:return 11;
break;
case 19:return 12;
break;
case 20:this.begin('NOTE_DUR'); return 46;
break;
case 21:return 38;
break;
case 22:return 35;
break;
case 23:return 40;
break;
case 24:return 39;
break;
case 25:return yy_.yytext;
break;
case 26:return 4;
break;
case 27:console.log('Unrecognized token: ', yy_.yytext);
break;
}
},
rules: [/^(?:((melody|harmony|percussion)))/,/^(?:(([0-9])))/,/^(?:((\r|\n|\r\n)))/,/^(?:\|:)/,/^(?:\|)/,/^(?::\|)/,/^(?::)/,/^(?:@)/,/^(?:(([A-GR][#b]{0,2})))/,/^(?:(([ |\t|\f|\v]))+)/,/^(?:\s+)/,/^(?:((%[^\r\n]*((\r|\n|\r\n)))))/,/^(?:((key_sig|time_sig|instrument|[k|t|i])))/,/^(?:((rate|volume|ctrls|[r|c|v])))/,/^(?:((out|scale|[o|s])))/,/^(?:(([0-9]))+)/,/^(?:\{[a-z_]+\})/,/^(?:[i])/,/^(?:(([0-9])))/,/^(?:\{(([0-9]))+\})/,/^(?:,)/,/^(?:[n])/,/^(?:[b])/,/^(?:~!)/,/^(?:~)/,/^(?:((,|;|\{|\}|\+|-|#|\/|\^)))/,/^(?:$)/,/^(?:.)/],
conditions: {"CTRL":{"rules":[2,3,4,5,6,7,8,9,12,13,14,15,16,25,26,27],"inclusive":true},"NOTE":{"rules":[2,3,4,5,6,7,8,9,18,19,20,21,22,23,24,25,26,27],"inclusive":true},"NOTE_DUR":{"rules":[2,3,4,5,6,7,8,9,15,25,26,27],"inclusive":true},"CHORD":{"rules":[3,4,5,6,7,8,9,17,18,25,26,27],"inclusive":true},"INITIAL":{"rules":[0,1,3,4,5,6,7,8,10,11,19,25,26,27],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = score_parser;
exports.Parser = score_parser.Parser;
exports.parse = function () { return score_parser.parse.apply(score_parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
};/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var schema_parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,3],$V1=[1,2],$V2=[1,5],$V3=[1,4,8,13],$V4=[7,8],$V5=[1,23],$V6=[1,26],$V7=[11,13],$V8=[1,33],$V9=[1,35],$Va=[1,39],$Vb=[1,37],$Vc=[1,38],$Vd=[1,34],$Ve=[1,36],$Vf=[11,13,28],$Vg=[11,28];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"e":3,"EOF":4,"RULE":5,"R":6,";":7,"IDENT":8,"=":9,"{":10,",":11,"OPTIONS":12,"}":13,"->":14,"NODES":15,"ACTION":16,"OPTION":17,":":18,"VAR":19,"NUMBER":20,"DIGITS":21,"BOOL":22,"true":23,"false":24,"STRING":25,"[":26,"LIST":27,"]":28,"$accept":0,"$end":1},
terminals_: {2:"error",4:"EOF",7:";",8:"IDENT",9:"=",10:"{",11:",",13:"}",14:"->",18:":",21:"DIGITS",23:"true",24:"false",25:"STRING",26:"[",28:"]"},
productions_: [0,[3,2],[3,2],[3,0],[5,2],[5,8],[6,3],[6,3],[6,2],[15,3],[15,0],[16,5],[17,3],[12,1],[12,3],[20,1],[22,1],[22,1],[19,1],[19,1],[19,1],[19,1],[19,2],[19,3],[19,3],[27,0],[27,1],[27,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

    this.$ = $$[$0-1];
    return this.$;
  
break;
case 2:

    $$[$0-1][$$[$0][0]] = $$[$0][1];
    this.$ = $$[$0-1];
  
break;
case 3:

    this.$ = {};
  
break;
case 4: case 9:

    this.$ = $$[$0-1];
  
break;
case 5:

    this.$ = [$$[$0-7], {mode: $$[$0-4]}];
    Object.assign(this.$[1], $$[$0-2]);
  
break;
case 6:

    this.$ = [$$[$0-2], {structure: [], node: $$[$0], action:{}}];
  
break;
case 7:

    $$[$0-2][1].action[ '_' + $$[$0-2][1].structure.length + "_" + $$[$0-1]] = $$[$0];
    $$[$0-2][1].structure.push($$[$0-1]);

  
break;
case 8:

    $$[$0-1][1].structure.push($$[$0]);
  
break;
case 10:

    this.$ = {}
  
break;
case 11:

    this.$ = {};
    this.$.mode = $$[$0-3];
    Object.assign(this.$, $$[$0-1]);
  
break;
case 12:

    this.$ = [$$[$0-2], $$[$0]];
  
break;
case 13:

    this.$ = {};
    this.$[$$[$0][0]] = $$[$0][1];
  
break;
case 14:

    $$[$0-2][$$[$0][0]] = $$[$0][1];
    this.$ = $$[$0-2];
  
break;
case 15:
 this.$ = parseFloat($$[$0]);
break;
case 16:

    this.$ = true;
  
break;
case 17:

    this.$ = false;
  
break;
case 18: case 19: case 20:
 this.$ = $$[$0];
break;
case 21:
 this.$ = $$[$0].substr(1,$$[$0].length - 2);
break;
case 22:
 this.$ = {};
break;
case 23: case 24:
 this.$ = $$[$0-1];
break;
case 25:
 this.$ = [];
break;
case 26:
 this.$ = [$$[$0]];
break;
case 27:
 $$[$0-2].push($$[$0]); this.$ = $$[$0-2];
break;
}
},
table: [o([1,4,8],$V0,{3:1}),{1:[3],4:$V1,5:3,6:4,8:$V2},o($V3,[2,1]),o($V3,[2,2]),{7:[1,6],8:[1,7]},{9:[1,8],14:[1,9]},o($V3,[2,4]),o($V4,[2,8],{16:10,10:[1,11]}),{10:[1,12]},o($V4,[2,10],{15:13,10:[1,14]}),o($V4,[2,7]),{8:[1,15]},{8:[1,16]},o($V4,[2,6]),o([4,8,13],$V0,{3:17}),{11:[1,18]},{11:[1,19]},{4:$V1,5:3,6:4,8:$V2,13:[1,20]},{8:$V5,12:21,17:22},{8:$V5,12:24,17:22},o($V4,[2,9]),{11:$V6,13:[1,25]},o($V7,[2,13]),{18:[1,27]},{11:$V6,13:[1,28]},o($V4,[2,11]),{8:$V5,17:29},{8:$V8,10:$V9,19:30,20:32,21:$Va,22:31,23:$Vb,24:$Vc,25:$Vd,26:$Ve},{7:[1,40]},o($V7,[2,14]),o($V7,[2,12]),o($Vf,[2,18]),o($Vf,[2,19]),o($Vf,[2,20]),o($Vf,[2,21]),{8:$V5,12:42,13:[1,41],17:22},o($Vg,[2,25],{22:31,20:32,27:43,19:44,8:$V8,10:$V9,21:$Va,23:$Vb,24:$Vc,25:$Vd,26:$Ve}),o($Vf,[2,16]),o($Vf,[2,17]),o($Vf,[2,15]),o($V3,[2,5]),o($Vf,[2,22]),{11:$V6,13:[1,45]},{11:[1,47],28:[1,46]},o($Vg,[2,26]),o($Vf,[2,24]),o($Vf,[2,23]),{8:$V8,10:$V9,19:48,20:32,21:$Va,22:31,23:$Vb,24:$Vc,25:$Vd,26:$Ve},o($Vg,[2,27])],
defaultActions: {},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};


/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip */
break;
case 1:/* skip */
break;
case 2:return 25;
break;
case 3:return yy_.yytext;
break;
case 4:return yy_.yytext;
break;
case 5:return 21;
break;
case 6:return 8;
break;
case 7:return 4;
break;
case 8:console.log('unrecognized token: ', yy_.yytext);
break;
}
},
rules: [/^(?:\s+)/,/^(?:((%[^\r\n]*((\r|\n|\r\n)))))/,/^(?:(("[^\"]+")))/,/^(?:((;|\{|\}|\[|\]|:|,|=|->)))/,/^(?:((true|false)))/,/^(?:(([+-]?[\d.]+)))/,/^(?:(([a-zA-z]\w*)))/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = schema_parser;
exports.Parser = schema_parser.Parser;
exports.parse = function () { return schema_parser.parse.apply(schema_parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
};// Generated by CoffeeScript 1.10.0
(function() {
  var MG, _seed, alias, gcd, lcm, ref1, ref2, ref3, roman,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MG = (ref1 = this.MG) != null ? ref1 : {};

  MG.instrs = {
    'Piano': ['1 Acoustic Grand Piano', '2 Bright Acoustic Piano', '3 Electric Grand Piano', '4 Honky-tonk Piano', '5 Electric Piano 1', '6 Electric Piano 2', '7 Harpsichord', '8 Clavinet'],
    'Chromatic Percussion': ['9 Celesta', '10 Glockenspiel', '11 Music Box', '12 Vibraphone', '13 Marimba', '14 Xylophone', '15 Tubular Bells', '16 Dulcimer'],
    'Organ': ['17 Drawbar Organ', '18 Percussive Organ', '19 Rock Organ', '20 Church Organ', '21 Reed Organ', '22 Accordion', '23 Harmonica', '24 Tango Accordion'],
    'Guitar': ['25 Acoustic Guitar (nylon)', '26 Acoustic Guitar (steel)', '27 Electric Guitar (jazz)', '28 Electric Guitar (clean)', '29 Electric Guitar (muted)', '30 Overdriven Guitar', '31 Distortion Guitar', '32 Guitar Harmonics'],
    'Bass': ['33 Acoustic Bass', '34 Electric Bass (finger)', '35 Electric Bass (pick)', '36 Fretless Bass', '37 Slap Bass 1', '38 Slap Bass 2', '39 Synth Bass 1', '40 Synth Bass 2'],
    'Strings': ['41 Violin', '42 Viola', '43 Cello', '44 Contrabass', '45 Tremolo Strings', '46 Pizzicato Strings', '47 Orchestral Harp', '48 Timpani'],
    'Ensemble': ['49 String Ensemble 1', '50 String Ensemble 2', '51 Synth Strings 1', '52 Synth Strings 2', '53 Choir Aahs', '54 Voice Oohs', '55 Synth Choir', '56 Orchestra Hit'],
    'Brass': ['57 Trumpet', '58 Trombone', '59 Tuba', '60 Muted Trumpet', '61 French Horn', '62 Brass Section', '63 Synth Brass 1', '64 Synth Brass 2'],
    'Reed': ['65 Soprano Sax', '66 Alto Sax', '67 Tenor Sax', '68 Baritone Sax', '69 Oboe', '70 English Horn', '71 Bassoon', '72 Clarinet'],
    'Pipe': ['73 Piccolo', '74 Flute', '75 Recorder', '76 Pan Flute', '77 Blown Bottle', '78 Shakuhachi', '79 Whistle', '80 Ocarina'],
    'Synth Lead': ['81 Lead 1 (square)', '82 Lead 2 (sawtooth)', '83 Lead 3 (calliope)', '84 Lead 4 (chiff)', '85 Lead 5 (charang)', '86 Lead 6 (voice)', '87 Lead 7 (fifths)', '88 Lead 8 (bass + lead)'],
    'Synth Pad': ['89 Pad 1 (new age)', '90 Pad 2 (warm)', '91 Pad 3 (polysynth)', '92 Pad 4 (choir)', '93 Pad 5 (bowed)', '94 Pad 6 (metallic)', '95 Pad 7 (halo)', '96 Pad 8 (sweep)'],
    'Synth Effects': ['97 FX 1 (rain)', '98 FX 2 (soundtrack)', '99 FX 3 (crystal)', '100 FX 4 (atmosphere)', '101 FX 5 (brightness)', '102 FX 6 (goblins)', '103 FX 7 (echoes)', '104 FX 8 (sci-fi)'],
    'Ethnic': ['105 Sitar', '106 Banjo', '107 Shamisen', '108 Koto', '109 Kalimba', '110 Bagpipe', '111 Fiddle', '112 Shanai'],
    'Percussive': ['113 Tinkle Bell', '114 Agogo', '115 Steel Drums', '116 Woodblock', '117 Taiko Drum', '118 Melodic Tom', '119 Synth Drum'],
    'Sound effects': ['120 Reverse Cymbal', '121 Guitar Fret Noise', '122 Breath Noise', '123 Seashore', '124 Bird Tweet', '125 Telephone Ring', '126 Helicopter', '127 Applause', '128 Gunshot']
  };

  MG.percussion = {
    27: "High-Q",
    28: "Slap",
    29: "Scratch Push",
    30: "Scratch Pull",
    31: "Sticks",
    32: "Square Click",
    33: "Metronome Click",
    34: "Metronome Bell",
    35: "Acoustic Bass Drum",
    36: "Bass Drum",
    37: "Side Stick",
    38: "Acoustic Snare",
    39: "Hand Clap",
    40: "Electric Snare",
    41: "Low Floor Tom",
    42: "Closed Hi Hat",
    43: "High Floor Tom",
    44: "Pedal Hi-Hat",
    45: "Low Tom",
    46: "Open Hi-Hat",
    47: "Low-Mid Tom",
    48: "Hi-Mid Tom",
    49: "Crash Cymbal 1",
    50: "High Tom",
    51: "Ride Cymbal 1",
    52: "Chinese Cymbal",
    53: "Ride Bell",
    54: "Tambourine",
    55: "Splash Cymbal",
    56: "Cowbell",
    57: "Crash Cymbal 2",
    58: "Vibraslap",
    59: "Ride Cymbal 2",
    60: "Hi Bongo",
    61: "Low Bongo",
    62: "Mute Hi Conga",
    63: "Open Hi Conga",
    64: "Low Conga",
    65: "High Timbale",
    66: "Low Timbale",
    67: "High Agogo",
    68: "Low Agogo",
    69: "Cabasa",
    70: "Maracas",
    71: "Short Whistle",
    72: "Long Whistle",
    73: "Short Guiro",
    74: "Long Guiro",
    75: "Claves",
    76: "Hi Wood Block",
    77: "Low Wood Block",
    78: "Mute Cuica",
    79: "Open Cuica",
    80: "Mute Triangle",
    81: "Open Triangle",
    82: "Shaker",
    83: "Jingle Bell",
    84: "Bell Tree",
    85: "Castanets",
    86: "Mute Surdo",
    87: "Open Surdo"
  };

  MG.arpeg = {
    "123": ["123", "13", "123 123", "13 13", "1 23", "1,2 23", "1 23 23", "1 2 3", "1 3 2", "1 3 2 3", "1 2 3 2", "1 2 3 2 3 2"],
    "1231+": ["1234", "134", "1 234", "1 2 3 4", "1 3 4 3", "1 2 3 4 3 2"],
    "132+": ["1 2 3 2 3 2 3 2"],
    "1-131+": ["12 3 4 3", "12,2 2 3 4,2 3,2"]
  };

  MG.texture = (function() {})();

  MG.chord_class = {
    "maj": [0, 4, 7],
    "min": [0, 3, 7],
    "dim": [0, 3, 6],
    "aug": [0, 4, 8],
    "sus2": [0, 2, 7],
    "sus4": [0, 5, 7],
    "dom7": [0, 4, 7, 10],
    "dom7b5": [0, 4, 6, 10],
    "min7": [0, 3, 7, 10],
    "min7b5": [0, 3, 6, 10],
    "aug7": [0, 4, 8, 10],
    "maj7": [0, 4, 7, 11],
    "maj7b5": [0, 4, 6, 11],
    "min7#": [0, 3, 7, 11],
    "aug7#": [0, 4, 8, 11],
    "dim7": [0, 3, 6, 9],
    "add9": [0, 2, 4, 7],
    "add11": [0, 4, 5, 7]
  };

  MG.chord_class_label = {
    "maj": "Major triad",
    "min": "Minor triad",
    "aug": "Augmented triad",
    "dim": "Diminished triad",
    "dom7": "Dominant seventh chord",
    "maj7": "Major seventh chord",
    "min7": "Minor seventh chord",
    "aug7": "Augmented seventh chord",
    "dim7": "Diminished seventh chord",
    "min7b5": "Half diminished chord",
    "min7#": "Minor seventh shart fifth chord",
    "sus2": "Suspended second chord",
    "sus4": "Suspended fourth chord",
    "add9": "Add ninth chord",
    "add11": "Add eleventh chord"
  };

  MG.inverted = function(arr, n) {
    var i, q, ref2, ret;
    if (n == null) {
      n = 1;
    }
    n = modulo(n, arr.length);
    ret = new Array(arr.length);
    for (i = q = 0, ref2 = arr.length; q < ref2; i = q += 1) {
      ret[i] = modulo(arr[(n + i) % arr.length] - arr[n], 12);
    }
    return ret;
  };

  MG.chords = (function() {
    var c, ci, i, q, ref2, ref3, res, v;
    res = {};
    ref2 = MG.chord_class;
    for (c in ref2) {
      v = ref2[c];
      ci = c + '';
      for (i = q = 0, ref3 = v.length; q < ref3; i = q += 1) {
        res[ci] = MG.inverted(v, i);
        ci += 'i';
      }
    }
    return res;
  })();

  MG.chord_finder = (function() {
    var k, ref2, ret, v;
    ret = {};
    ref2 = MG.chords;
    for (k in ref2) {
      v = ref2[k];
      if (v.toString() in ret) {

      } else {
        ret[v.toString()] = k;
      }
    }
    ret[[0, 5, 7].toString()] = 'sus4';
    return ret;
  })();

  MG.interval_class = {
    'u1': 0,
    'm2': 1,
    'M2': 2,
    'm3': 3,
    'M3': 4,
    'p4': 5,
    'a4': 6,
    'd5': 6,
    'p5': 7,
    'm6': 8,
    'M6': 9,
    'm7': 10,
    'M7': 11,
    'o8': 12
  };

  MG.consonant_interval = ['u1', 'p4', 'p5', 'm6', 'M6', 'o8', 0, 3, 4, 5, 7, 8, 9];

  MG.dissonant_interval = ['m2', 'M2', 'a4', 'd5', 'm7', 'M7', 1, 2, 6, 10, 11];

  MG.key_class = (function() {
    var kn1, kn2, res;
    kn1 = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    kn2 = ['B#', 'C#', 'D', 'D#', 'Fb', 'E#', 'F#', 'G', 'G#', 'A', 'A#', 'Cb'];
    res = {};
    kn1.forEach(function(e, i) {
      res[e] = i;
    });
    kn2.forEach(function(e, i) {
      res[e] = i;
    });
    return res;
  })();

  MG.scale_class = {
    'maj': [0, 2, 4, 5, 7, 9, 11],
    'min': [0, 2, 3, 5, 7, 8, 10],
    'min_harmonic': [0, 2, 3, 5, 7, 8, 11],
    'maj_harmonic': [0, 2, 4, 5, 8, 9, 11],
    'min_melodic': [0, 2, 3, 5, 7, 9, 11],
    'chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    'octatonic': [0, 1, 3, 4, 6, 7, 9, 10],
    'whole': [0, 2, 4, 6, 8, 10],
    'dorian': [0, 2, 3, 5, 7, 9, 10],
    'lydian': [0, 2, 4, 6, 7, 9, 11],
    'pent': [0, 2, 4, 7, 9],
    'pent_min': [0, 3, 5, 7, 10],
    'zhi': [0, 2, 5, 7, 9],
    'blues': [0, 3, 5, 6, 7, 10]
  };

  this.white_key_num = MG.scale_class['maj'];

  this.black_key_num = [1, 3, 6, 8, 10];

  MG.scaleToPitch = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(num) {
      return ref + (Math.floor(num / scale.length)) * 12 + scale[modulo(num, scale.length)] + 12;
    };
  };

  MG.pitchToScale = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(pitch) {
      var i, oct, q, ref4;
      pitch -= ref;
      oct = Math.floor(pitch / 12) - 1;
      pitch = modulo(pitch, 12);
      for (i = q = ref4 = scale.length - 1; q >= 0; i = q += -1) {
        if (pitch >= scale[i]) {
          return [i, oct, pitch - scale[i]];
        }
      }
      return [0, oct, pitch - scale[0]];
    };
  };

  MG.testPitchScaleConversion = function() {
    var flag, i, j, mode, q, ref2, scale, tmp, toPitch, toScale, tonic;
    ref2 = MG.scale_class;
    for (scale in ref2) {
      mode = ref2[scale];
      flag = true;
      for (tonic in MG.key_class) {
        toPitch = MG.scaleToPitch(scale, tonic);
        toScale = MG.pitchToScale(scale, tonic);
        for (i = q = 21; q <= 108; i = ++q) {
          tmp = toScale(i);
          j = toPitch(tmp[0] + mode.length * tmp[1]) + tmp[2];
          if (j !== i) {
            flag = false;
            console.log(tonic, scale, i, tmp, j);
          }
        }
      }
      if (flag) {
        console.log(scale, 'success');
      }
    }
  };

  MG.keyToPitch = function(key) {
    var key_class, oct, ref, ref2, ref3;
    key_class = /[A-G][#b]{0,2}/.exec(key)[0];
    if (key_class == null) {
      key_class = 'C';
    }
    ref = (ref2 = MG.key_class[key_class]) != null ? ref2 : 0;
    oct = /[0-9]/.exec(key)[0];
    oct = (ref3 = parseInt(oct)) != null ? ref3 : 4;
    return 12 + ref + oct * 12;
  };

  MG.pitchToKey = function(pitch, sharp, nooct) {
    var kn, ref;
    if (pitch < 21 || pitch > 108) {
      return void 0;
    }
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    if (sharp === true) {
      kn = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    }
    ref = pitch % 12;
    if (nooct != null) {
      return kn[ref];
    } else {
      return [kn[ref], Math.floor(pitch / 12) - 1];
    }
  };

  MG.testPitchKeyConversion = function() {
    var flag, i, j, q, tmp;
    flag = true;
    for (i = q = 21; q <= 108; i = ++q) {
      tmp = MG.pitchToKey(i, true);
      j = MG.keyToPitch(tmp[0] + tmp[1]);
      if (j !== i) {
        flag = false;
        console.log(i, tmp, j);
      }
    }
    if (flag) {
      console.log('success');
    }
  };

  MG.transposer = function(scale_name, key_sig) {
    var scale_len, toPitch, toScale;
    if (scale_name == null) {
      scale_name = 'chromatic';
    }
    console.log(scale_name, 'transposer');
    if (key_sig == null) {
      key_sig = 'C';
    }
    scale_len = MG.scale_class[scale_name].length;
    toScale = MG.pitchToScale(scale_name, key_sig);
    toPitch = MG.scaleToPitch(scale_name, key_sig);
    return function(pitch, diff) {
      var tmp;
      tmp = toScale(pitch);
      return toPitch(tmp[0] + tmp[1] * scale_len + diff) + tmp[2];
    };
  };

  alias = {
    '7': 'dom7',
    '': 'maj',
    'M': 'maj',
    'm': 'min',
    'mi': 'min',
    'm7': 'min7'
  };

  roman = (function() {
    var arr, res;
    arr = ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii'];
    res = {};
    arr.forEach(function(e, i) {
      return res[e.toUpperCase()] = res[e] = i;
    });
    return res;
  })();

  MG.getChords = function(chord_str, oct, key_sig) {
    var chord_name, chord_pitches, ex, ex2, lastIndex, r, ref2, root, root_pitch;
    ex = /[A-G][b#]{0,2}/;
    ex2 = /([VvIi]+)([b#]{0,2})/;
    if (key_sig == null) {
      key_sig = 'C';
    }
    if (oct == null) {
      oct = 4;
    }
    r = ex.exec(chord_str);
    root = 'C';
    lastIndex = 0;
    if (r !== null) {
      root = r[0];
      lastIndex = r.index + r[0].length;
    } else {
      r = ex2.exec(chord_str);
      if (r !== null) {
        root = MG.scale_keys[key_sig][roman[r[1]]] + (r[2] || '');
        root = root.replace(/b#/g, '').replace(/#b/g, '');
        lastIndex = r.index + r[0].length;
      }
    }
    root_pitch = MG.keyToPitch(root + oct);
    chord_name = chord_str.substr(lastIndex);
    chord_name = (ref2 = alias[chord_name]) != null ? ref2 : chord_name;
    chord_pitches = MG.chords[chord_name] || MG.chords['maj'];
    return [root_pitch, chord_pitches];
  };

  MG.keyToRoman = function(key_sig) {
    var arr, toScale;
    if (key_sig == null) {
      key_sig = 'C';
    }
    arr = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
    toScale = MG.pitchToScale('maj', key_sig);
    return function(key) {
      var num, pitch, tmp;
      pitch = MG.keyToPitch(key + '4');
      tmp = toScale(pitch);
      num = arr[tmp[0]];
      if (tmp[2] > 0) {
        num += '#';
      }
      return num;
    };
  };

  MG.key_sig_rev = {};

  MG.key_sig = (function() {
    var i, j, kn, l, q, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    for (i = q = 0; q < 12; i = q += 1) {
      j = (i * 7) % 12;
      l = (i + 6) % 12 - 6;
      res[kn[j]] = l;
      MG.key_sig_rev[l] = kn[j];
    }
    res['F#'] = 6;
    MG.key_sig_rev[6] = 'F#';
    return res;
  })();

  MG.keyNames = (function() {
    var ref, res;
    res = new Array(12).fill(0).map(function(e) {
      return [];
    });
    ref = MG.scale_class['maj'];
    "CDEFGAB".split("").forEach(function(key, i) {
      res[modulo(ref[i] - 2, 12)].push(key + 'bb');
      res[modulo(ref[i] - 1, 12)].push(key + 'b');
      res[ref[i] % 12].push(key);
      res[(ref[i] + 1) % 12].push(key + '#');
      return res[(ref[i] + 2) % 12].push(key + '##');
    });
    return res;
  })();

  MG.scale_keys = (function() {
    var kn, ref, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    res['C'] = "CDEFGAB".split("");
    ref = MG.scale_class['maj'];
    kn.forEach(function(e, i) {
      var j, k, notes, pitch, q, ref2, results, v;
      if (e === 'C') {
        return;
      }
      res[e] = [e];
      results = [];
      for (j = q = 1, ref2 = ref.length; q < ref2; j = q += 1) {
        pitch = (i + ref[j]) % 12;
        notes = MG.keyNames[pitch];
        results.push((function() {
          var results1;
          results1 = [];
          for (k in notes) {
            v = notes[k];
            if (v[0] === res['C'][(res['C'].indexOf(e[0]) + j) % 7]) {
              res[e].push(v);
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    });
    return res;
  })();


  /*
      sample data
   */

  this.score_summer = MG.score_summer = {
    settings: {
      tempo: 120,
      time_sig: [4, 4],
      key_sig: 'C',
      scale: 'maj',
      ctrl_per_beat: 16,
      volumes: [110, 80],
      instrs: [66, 1]
    },
    contents: {
      melody: ':+ 0,2 3 1/3,1^/3,2 2 1 2 3 1,2/:- 6 3,1^/3,2 :+ 3 1/2 2,7^/2,2 1 6- 1 6- 1,2/:- 7,1^/7,4 0 :+ 3,2 1/3 3,2 3,1^ 3,4^/3,2 2 1 2 3 1,2/:- 6 3,1^/3,3 3/5,2 3 5 6,2 :+ 1,2/3 2,3 1,4/:- 6,1^/6,2 :+ 3 1'.split('/'),
      harmony: "E7/Amin/Bb7/Amin E7/Amin A7/Dmin/F7/F#min7 B7/E7/Am/Bb7/Am/D7/C Am/D7 E7/Am D7/Bm7 E7".split('/'),
      texture: "@-123 0 123/@-11-32+ 12 3 4 3/@iii-11-32+ 12 3 4 3/@-123 123 @-123 123/@-123 123 @-123 123/@-11-32+ 12 3 4 3/@-11-32+ 12 3 4 3/@-123 123 123/@-11-32+ 12 3 4 3/@-123 123 123/@-123 123 123/@-123 123 123/@-123 123 123/@-123 123 @-123 123/@-123 123 @-123 123/@-123 123 @-123 123/@-123 123 @-123 123".split('/')
    }
  };

  this.gen_modes = ['random', 'transpose', 'chord', 'reverse', 'diminuation', 'augmentation'];

  this.schema_summer = MG.schema_summer = {
    'S': {
      structure: "c/A/B/Br/A/C/c".split('/'),
      node: {
        'c': {
          mode: 'random',
          dur: 4 * 8,
          incomplete_start: 32,
          chord_tone: 4,
          scale_tone: [2, 1, 1, 0.5, 2, 1, 0.5],
          chords: ["E7"],
          rhythm: {
            seed: 's1',
            swarp: 0.5
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        },
        'A': {
          mode: 'random',
          dur: 32 * 8,
          chord_tone: 4,
          chromatic_tone: 0.5,
          chords: ["Amin", "Bb7", "Amin E7", "Amin A7"],
          rhythm: {
            seed: 's1',
            swarp: 0.5
          },
          interval: {
            chromatic: false,
            seed: 's2'
          },
          range: [56, 77],
          dist: 'linear'
        },
        'B': {
          structure: ['A'],
          action: {
            'A': {
              mode: 'transpose',
              dur: 16 * 8,
              offset: 0,
              scale: 'maj',
              interval: 3
            }
          }
        },
        'Br': {
          structure: ['B'],
          action: {
            'B': {
              mode: 'reverse',
              deep: true
            }
          }
        },
        'C': {
          mode: 'random',
          dur: 28 * 8,
          incomplete_end: 32,
          chord_tone: 4,
          chords: "C Am/D7 E7/Am D7/Bm7".split('/'),
          rhythm: {
            seed: 's1',
            swarp: 0.5
          },
          interval: {
            chromatic: false,
            seed: 's2'
          },
          range: [56, 77],
          dist: 'quadratic'
        }
      }
    },
    's1': {
      mode: "distribution",
      dur: 16,
      choices: '4 4 4 4/8 4 4/4 4 8/4 8 4/4 12/12 4/8 8/16'.split('/').map(function(e) {
        return e.split(/\s+/).map(function(e2) {
          return parseInt(e2);
        });
      }),
      weights: [1, 3, 3, 5, 1, 5, 8, 8]
    },
    's2': {
      mode: "distribution",
      weights: [1, 2, 5, 12, 6, 30, 8, 30, 12, 8, 3, 1, 1],
      choices: (function() {
        return Array(13).fill().map(function(e, i) {
          return i - 6;
        });
      })()
    }
  };

  MG.score_dance = {
    key_sig: 'C'
  };

  MG.schema_dance = 'S';


  /*
    utilities
   */

  MG.clone = (function() {
    var clone;
    clone = function(o) {
      var i, ret;
      if (typeof o !== 'object' || o === null) {
        return o;
      } else {
        ret = Array.isArray(o) ? [] : {};
        for (i in o) {
          ret[i] = clone(o[i]);
        }
        return ret;
      }
    };
    return function(o) {
      return clone(o);
    };
  })();

  MG.circularClone = function(obj) {
    var clone, getVisited, visited;
    visited = [];
    getVisited = function(o) {
      var i;
      i = 0;
      while (i < visited.length) {
        if (visited[i][0] === o) {
          return visited[i][1];
        }
        ++i;
      }
      return null;
    };
    clone = function(o) {
      var i, ret;
      if (typeof o !== 'object' || o === null) {
        return o;
      }
      ret = getVisited(o);
      if (ret !== null) {
        return ret;
      }
      ret = Array.isArray(o) ? [] : {};
      visited.push([o, ret]);
      for (i in o) {
        ret[i] = clone(o[i]);
      }
      return ret;
    };
    return clone(obj);
  };

  MG.top_sort = function(dependency) {
    var get_one, n, remove_one, ret, tmp;
    n = Object.keys(dependency).length;
    remove_one = function(o) {
      var k, v;
      for (k in dependency) {
        v = dependency[k];
        if (indexOf.call(v, o) >= 0) {
          v.splice(v.indexOf(o), 1);
        }
      }
      return delete dependency[o];
    };
    get_one = function() {
      var k, v;
      for (k in dependency) {
        v = dependency[k];
        if (v.length <= 0) {
          return k;
        }
      }
      return null;
    };
    ret = [];
    while (ret.length < n) {
      tmp = get_one();
      if (tmp === null) {
        console.log('circular dependency', dependency);
        break;
      } else {
        ret.push(tmp);
        remove_one(tmp);
      }
    }
    return ret;
  };

  gcd = function(a, b) {
    var tmp;
    while (b > 0) {
      tmp = b;
      b = a % b;
      a = tmp;
    }
    return a;
  };

  lcm = function(a, b) {
    return a / gcd(a, b) * b;
  };

  MG.gcd = function() {
    var i, q, ref2, ret;
    ret = gcd(arguments[0], arguments[1]);
    for (i = q = 2, ref2 = arguments.length; q < ref2; i = q += 1) {
      ret = gcd(ret, arguments[i]);
    }
    return ret;
  };

  MG.lcm = function() {
    var i, q, ref2, ret;
    ret = lcm(arguments[0], arguments[1]);
    for (i = q = 2, ref2 = arguments.length; q < ref2; i = q += 1) {
      ret = lcm(ret, arguments[i]);
    }
    return ret;
  };

  MG.condCopy = function(src, dest, props) {
    var i, len, q;
    for (q = 0, len = props.length; q < len; q++) {
      i = props[q];
      if (src[i] != null) {
        dest[i] = src[i];
      }
    }
  };

  MG.obj_sort = function(data, decending, map) {
    var kv;
    if (decending == null) {
      decending = false;
    }
    if (map == null) {
      map = function(e) {
        return e;
      };
    }
    kv = _.zip(_.keys(data), _.values(data));
    if (decending) {
      kv.sort(function(a, b) {
        return map(b[1]) - map(a[1]);
      });
    } else {
      kv.sort(function(a, b) {
        return map(a[1]) - map(b[1]);
      });
    }
    return kv;
  };

  _seed = 6;

  MG.seededRandom = function(max, min) {
    var rnd;
    max = max || 1;
    min = min || 0;
    _seed = (_seed * 9301 + 49297) % 233280;
    rnd = _seed / 233280;
    return min + rnd * (max - min);
  };


  /*
    parsers
   */

  MG.parseHarmony = function(measures, key_sig, tatum) {
    if (typeof measures === 'undefined') {
      console.log('empty harmony');
      return;
    }
    return measures.map(function(e) {
      var durs, r, ret;
      durs = [];
      ret = e.trim().split(/\s+/).map(function(e2) {
        var chord_info, dur, terms;
        terms = e2.split(',');
        chord_info = MG.getChords(terms[0], 3, key_sig);
        dur = terms.length >= 2 ? parseInt(terms[1]) : 1;
        durs.push(dur);
        return [dur, chord_info[0], chord_info[1]];
      });
      if (tatum != null) {
        r = tatum / math.sum(durs);
        durs = [];
        ret.forEach(function(ee, ii) {
          return durs.push(ret[ii][0] = Math.floor(ee[0] * r));
        });
        ret[ret.length - 1][0] += tatum - math.sum(durs);
      }
      return ret;
    });
  };

  MG.harmony_progresser = function(harmony) {
    var b_i, bass, chord, delta, forward, incr, m_i, process;
    if (harmony == null) {
      harmony = [];
    }
    m_i = 0;
    b_i = -1;
    delta = 0;
    bass = function(inv) {
      var curchord;
      if (inv == null) {
        inv = 0;
      }
      curchord = harmony[m_i][b_i];
      return (curchord[1] + curchord[2][inv]) % 12;
    };
    incr = function() {
      b_i++;
      if (b_i >= harmony[m_i].length) {
        b_i = 0;
        m_i++;
        if (m_i >= harmony.length) {
          m_i = harmony.length - 1;
        }
      }
      delta -= harmony[m_i][b_i][0];
      return delta;
    };
    chord = function(inv) {
      if (inv == null) {
        inv = 0;
      }
      return MG.inverted(harmony[m_i][b_i][2], inv);
    };
    forward = function(d) {
      return delta += d;
    };
    process = function() {
      var results;
      results = [];
      while (m_i < harmony.length && delta >= 0) {
        results.push(incr());
      }
      return results;
    };
    return {
      bass: bass,
      chord: chord,
      process: process,
      forward: forward
    };
  };

  MG.score_parser = (ref2 = this.score_parser) != null ? ref2 : require('./js/score_parser');

  MG.schema_parser = (ref3 = this.schema_parser) != null ? ref3 : require('./js/schema_parser');

  MG.schema_parser.produce = function(obj) {
    var indent, produce, produceVar;
    produceVar = function(o, indent) {
      var k, len, q, ret, tmp, v;
      if (indent == null) {
        indent = '';
      }
      ret = '';
      tmp = [];
      if (Array.isArray(o)) {
        ret += '[\n';
        indent += '  ';
        for (q = 0, len = o.length; q < len; q++) {
          k = o[q];
          tmp.push(indent + produceVar(k, indent));
        }
        ret += tmp.join(',\n');
        indent = indent.substr(2);
        ret += '\n' + indent + ']';
      } else if (typeof o === 'object') {
        ret = '{\n';
        indent += '  ';
        for (k in o) {
          v = o[k];
          if (k === 'mode') {
            tmp.push(indent + v.toString());
          } else {
            tmp.push(indent + k + ' : ' + produceVar(v, indent));
          }
        }
        ret += tmp.join(',\n');
        indent = indent.substr(2);
        ret += '\n' + indent + '}';
      } else if (typeof o === 'string') {
        ret += '"' + o + '"';
      } else {
        ret += o.toString();
      }
      return ret;
    };
    produce = function(nodes, indent) {
      var k, ret, v;
      if (indent == null) {
        indent = '';
      }
      ret = '';
      indent += '  ';
      for (k in nodes) {
        v = nodes[k];
        if (v.structure != null) {
          ret += indent + k + ' -> ';
          if ((v.node != null) && Object.keys(v.node).length > 0) {
            ret += '{\n';
            ret += produce(v.node, indent);
            ret += indent + '}';
          }
          ret += '\n';
          v.structure.forEach(function(e, i) {
            var ref4, tgt;
            ret += indent + e + ' ';
            if (v.action != null) {
              tgt = (ref4 = v.action[e]) != null ? ref4 : v.action["_" + i + "_" + e];
              if (tgt != null) {
                ret += produceVar(tgt, indent);
              }
            }
            return ret += '\n';
          });
          ret += indent + ';\n';
        } else {
          ret += indent + k + ' = ';
          ret += produceVar(v, indent) + ';\n';
        }
      }
      indent = indent.substr(2);
      return ret;
    };
    indent = '';
    return produce(obj, indent);
  };

  MG.parseMelody = function(m, options) {
    var chorder, e, error, harmony, init_ref, key_sig_map, obj, ornamental, ref, refc, res, scale, tatum, tempo_map, time_sig_map;
    try {
      obj = MG.score_parser.parse(m.join('\n') + '\n');
    } catch (error) {
      e = error;
      $.notify('parsing error!', 'warning');
      console.log(e.message);
      return;
    }
    ornamental = function(pitch, ref, scale) {
      var p;
      p = typeof pitch === 'number' ? pitch : pitch.original;
      if (p > scale.length) {
        console.log('exceed scale length');
        p = scale.length;
      } else if (p === 0) {
        return 0;
      }
      p = ref + scale[p - 1];
      if (typeof pitch !== 'number') {
        pitch.ornament.forEach(function(e) {
          if (typeof e === 'number') {
            return p += e;
          }
        });
      }
      return p;
    };
    switch (obj.mode) {
      case 'melody':
        scale = options.scale, init_ref = options.init_ref, harmony = options.harmony;
        break;
      case 'harmony':
        harmony = options.harmony;
    }
    tatum = options.ctrl_per_beat * options.time_sig[0];
    refc = null;
    chorder = MG.harmony_progresser(harmony);
    if (scale == null) {
      scale = MG.scale_class['maj'];
    }
    tempo_map = {
      0: options.tempo
    };
    key_sig_map = {
      0: options.key_sig
    };
    time_sig_map = {
      0: options.time_sig
    };
    if (init_ref == null) {
      init_ref = 60;
    }
    ref = init_ref;
    res = obj.data.map(function(m, i) {
      var dur_tot, durs, measure, r;
      measure = [];
      dur_tot = 0;
      durs = [];
      m.forEach(function(e) {
        if (e.ctrl == null) {
          if (typeof e.dur === 'number') {
            dur_tot += e.dur;
            return durs.push(e.dur);
          } else {
            dur_tot += e.dur.original;
            return durs.push(e.dur.original);
          }
        }
      });
      if (tatum != null) {
        r = Math.floor(tatum / dur_tot);
        dur_tot = 0;
        m.forEach(function(e) {
          if (e.ctrl == null) {
            if (typeof e.dur === 'number') {
              e.dur *= r;
              return dur_tot += e.dur;
            } else {
              e.dur.original *= r;
              return dur_tot += e.dur.original;
            }
          }
        });
      }
      m.forEach(function(e) {
        var bass, chord, k, pitches, results, v;
        if (e.ctrl != null) {
          switch (e.ctrl) {
            case 'reset':
              return ref = init_ref;
            case 'normal':
            case 'repeat_start':
              results = [];
              for (k in e) {
                v = e[k];
                switch (k) {
                  case 't':
                    time_sig_map[i] = v;
                    results.push(tatum = options.ctrl_per_beat * v[0]);
                    break;
                  case 's':
                    results.push(scale = MG.scale_class[v]);
                    break;
                  case 'k':
                    key_sig_map[i] = v;
                    results.push(ref = init_ref = MG.keyToPitch(v + 4));
                    break;
                  case 'r':
                    results.push(tempo_map[i] = v);
                    break;
                  case 'v':
                    results.push(1);
                    break;
                  case 'o':
                    results.push(1);
                    break;
                  case 'i':
                    results.push(1);
                    break;
                  case 'p':
                    results.push(ref += v);
                    break;
                  default:
                    results.push(void 0);
                }
              }
              return results;
              break;
            case 'chord':
              ref = MG.keyToPitch('C3');
              chorder.process();
              bass = chorder.bass(e.inv);
              chord = chorder.chord(e.inv);
              ref += e.transpose;
              bass += ref;
              return refc = e.pitch.map(function(p) {
                return ornamental(p, bass, chord);
              });
          }
        } else {
          pitches = [];
          e.pitch.forEach(function(p) {
            if (typeof p === 'string') {

            } else if (refc != null) {
              if (refc[p - 1] != null) {
                return pitches.push(refc[p - 1]);
              }
            } else {
              return pitches.push(ornamental(p, ref, scale));
            }
          });
          if (typeof e.dur === 'number') {
            measure.push([e.dur, pitches]);
            return chorder.forward(e.dur);
          } else {
            measure.push([e.dur.original, pitches, true]);
            return chorder.forward(e.dur.original);
          }
        }
      });
      if ((tatum != null) && dur_tot < tatum) {
        console.log('not enough');
        measure[measure.length - 1][0] += tatum - dur_tot;
      }
      return measure;
    });
    res.info = {
      time_sigs: time_sig_map,
      key_sigs: key_sig_map,
      tempi: tempo_map
    };
    return res;
  };

  this.MG = MG;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MG;
  }

}).call(this);

//# sourceMappingURL=musical.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var Analyzer, MG, midi_statistics, obj_sort, seqPlayer;

  MG = this.MG || ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null) && require('./musical')) || {};


  /*
    player for note sequence
    warn: based of setTimeout, may slow down in background
   */

  seqPlayer = (function() {
    function seqPlayer() {
      this.harmony = [];
      this.instrs = [];
      this.tracks = [];
      this.playing = [];
      this.cur_i = [];
      this.midi = null;
      this.raw_midi = '';
      this.onend = function(n) {
        return console.log("track " + n + " finished");
      };
    }

    seqPlayer.prototype.play = function(n) {
      var channel, cur, cur_i, loop1, nexti, onend, playing, q, rate;
      if (n == null) {
        n = 0;
      }
      if ((this.tracks[n] == null) || this.tracks[n].length <= 0) {
        return;
      }
      q = this.tracks[n];
      nexti = this.cur_i[n];
      cur_i = this.cur_i;
      cur = q[nexti];
      nexti++;
      channel = n;
      rate = 1;
      onend = this.onend;
      playing = this.playing;
      playing[n] = true;
      loop1 = (function(_this) {
        return function() {
          var dur, notes;
          if (cur[0] > 0) {
            notes = typeof cur[1] !== 'object' ? [cur[1]] : cur[1];
            notes.forEach(function(e) {
              if (e >= 21 && e <= 108) {
                MIDI.noteOn(channel, e, cur[2]);
              }
            });
          }
          dur = cur[0] >= 0 ? cur[0] : -cur[0];
          dur *= rate;
          setTimeout((function() {
            notes = typeof cur[1] !== 'object' ? [cur[1]] : cur[1];
            if (nexti < 0) {
              notes.forEach(function(e) {
                if (e >= 21 && e <= 108) {
                  MIDI.noteOff(channel, e);
                }
              });
              playing[n] = false;
              onend.call(_this, n);
            } else {
              if (q[nexti][0] > 0) {
                notes.forEach(function(e) {
                  if (e >= 21 && e <= 108) {
                    MIDI.noteOff(channel, e);
                  }
                });
              }
              cur = q[nexti];
              if (playing[n]) {
                nexti++;
                if (nexti >= q.length) {
                  nexti = -1;
                  cur_i[n] = 0;
                }
              } else {
                cur_i[n] = nexti;
                nexti = -1;
              }
              loop1();
            }
          }), dur);
        };
      })(this);
      setTimeout(loop1, 0);
    };

    seqPlayer.prototype.toQ = function(arr, ctrlTicks, vol) {
      var delta, info, j, m, ref, res;
      info = (ref = arr.info) != null ? ref : {};
      if (vol == null) {
        vol = 110;
      }
      m = _.flatten(arr, true);
      res = [];
      j = 0;
      while (j < m.length) {
        delta = m[j][0];
        while (m[j][2] === true && j + 1 < m.length) {
          j++;
          delta += m[j][0];
        }
        res.push([delta * ctrlTicks, m[j][1], vol]);
        ++j;
      }
      return res;
    };

    seqPlayer.prototype.pause = function(n) {
      if (n == null) {
        n = 0;
      }
      if (n >= this.tracks.length || n < 0) {
        return;
      }
      this.playing[n] = false;
    };

    seqPlayer.prototype.stop = function(n) {
      if (n == null) {
        n = 0;
      }
      if (n >= this.tracks.length) {
        return;
      }
      this.playing[n] = false;
      this.cur_i[n] = 0;
    };

    seqPlayer.prototype.fromScore = function(obj) {
      var ctrlTicks, i, k, ref;
      ctrlTicks = obj.init_ctrlTicks;
      this.tracks = [];
      this.instrs = MG.clone(obj.instrs);
      this.playing = [];
      this.cur_i = [];
      this.harmony = obj.harmony;
      this.midi = obj.toMidi();
      this.raw_midi = MidiWriter(this.midi);
      for (i = k = 0, ref = obj.tracks.length; k < ref; i = k += 1) {
        this.tracks.push(this.toQ(obj.tracks[i], ctrlTicks, obj.volumes[i]));
        this.playing.push(false);
        this.cur_i.push(0);
      }
    };

    seqPlayer.prototype.saveMidi = function() {
      var bf;
      if (this.raw_midi.length < 1) {
        return;
      }
      bf = new Uint8Array(this.raw_midi.split('').map(function(e) {
        return e.charCodeAt(0);
      }));
      saveAs(new Blob([bf], {
        type: 'audio/midi'
      }), 'sample.mid');
    };

    return seqPlayer;

  })();

  Analyzer = (function() {
    function Analyzer(key_sig, scale_name) {
      this.key_sig = key_sig;
      this.scale_name = scale_name;
      this.scale = MG.scale_class[this.scale_name];
      this.key_ref = MG.key_class[this.key_sig];
      this.toScale = MG.pitchToScale(this.scale_name, this.key_sig);
      this.key_sig_acc = MG.key_sig[this.key_sig];
    }

    Analyzer.prototype.pitch_info = function(pitch, chord) {
      var i, info, key, p, ref, sharp, tmp;
      info = {};
      if (chord != null) {
        if (typeof chord === 'string') {
          chord = MG.getChords(chord, 3, this.key_sig);
        }
        info.isChordTone = false;
        ref = chord[1];
        for (i in ref) {
          p = ref[i];
          if ((chord[0] + p - pitch) % 12 === 0) {
            info.isChordTone = true;
            break;
          }
        }
      }
      tmp = this.toScale(pitch);
      info.inScale = tmp[2] === 0;
      key = MG.scale_keys[s.key_sig][tmp[0]];
      sharp = MG.key_sig[this.key_sig] >= 0;
      info.keyName = info.inScale ? [
        key, Math.floor(pitch / 12) - ({
          'Cb': 0,
          'B#': 2
        }[key] || 1)
      ] : MG.pitchToKey(pitch, sharp);
      return info;
    };

    return Analyzer;

  })();

  obj_sort = function(data) {
    return MG.obj_sort(data, true);
  };

  MG.midi_statistics = midi_statistics = function(obj) {
    var info, n_one, n_two, one, two;
    info = {
      rhythm: {},
      melody: {
        one: {},
        two: {}
      },
      range: []
    };
    one = {};
    two = {};
    n_one = 0;
    n_two = 0;
    obj.forEach(function(e, ii) {
      var c, i, measure, r;
      measure = _.unzip(e);
      r = measure[0];
      info.rhythm[r] = 1 + (info.rhythm[r] || 0);
      r = measure[1];
      info.range.push(_.max(r) - _.min(r));
      if (r.length < 2) {
        return;
      }
      c = [r[0] % 12, (r[1] - r[0]) % 12];
      if (one[c] == null) {
        one[c] = 0;
      }
      one[c]++;
      n_one++;
      i = 2;
      while (i < r.length) {
        c = [r[i - 1] % 12, (r[i] - r[i - 1]) % 12];
        one[c] = 1 + (one[c] || 0);
        n_one++;
        c = [r[i - 2] % 12, (r[i - 1] - r[i - 2]) % 12, c[1]];
        two[c] = 1 + (two[c] || 0);
        n_two++;
        ++i;
      }
    });
    return info = {
      rhythm: MG.obj_sort(info.rhythm, true),
      melody: {
        one: MG.obj_sort(one, true),
        two: MG.obj_sort(two, true),
        n: [0, n_one, n_two]
      },
      range: info.range
    };
  };

  this.AppMG = (function() {
    function AppMG(ui, options) {
      var options_container, tracks_container;
      this.ui = ui;
      tracks_container = $(this.ui.tracks_container);
      options_container = $(this.ui.options_container);
      this.tracks_tabs = tracks_container.children('.nav-tabs');
      this.tracks_contents = tracks_container.children('.tab-content');
      this.options_tabs = options_container.children('.nav-tabs');
      this.options_contents = options_container.children('.tab-content');
      this.renderer = new ScoreRenderer(this.ui.renderer[0], void 0, this.ui.renderer[1]);
      this.editor = {};
      this.ui.editor[0].forEach((function(_this) {
        return function(id, i) {
          var editor, ele, wrapper;
          wrapper = "track_" + i;
          ele = $('<li data-toggle="tab" data-target="#' + wrapper + '"><a href="#' + wrapper + '">' + id[0].toUpperCase() + id.substr(1) + '</a></li>');
          ele.children().append($('<span class="glyphicon glyphicon-play"></span>'));
          _this.tracks_tabs.children('li.tab_plus').before(ele);
          ele = $('<div class="tab-pane" id="' + wrapper + '"><div class="editor" id="ace_' + id.toLowerCase() + '" style="height:300px"></div></div>');
          _this.tracks_contents.append(ele);
          editor = ace.edit('ace_' + id.toLowerCase());
          editor.setTheme("ace/theme/clouds");
          editor.getSession().setMode("ace/mode/" + _this.ui.modes[0][i]);
          editor.setFontSize(16);
          editor.$blockScrolling = Infinity;
          return _this.editor[id] = editor;
        };
      })(this));
      this.tracks_tabs.children().first().addClass('active');
      this.tracks_contents.children().first().addClass('active in');
      this.ui.editor[1].forEach((function(_this) {
        return function(id, i) {
          var editor, ele, wrapper;
          wrapper = "options_" + i;
          ele = $('<li data-toggle="tab" data-target="#' + wrapper + '"><a href="#' + wrapper + '">' + id[0].toUpperCase() + id.substr(1) + '</a></li>');
          _this.options_tabs.children('li.tab_plus').before(ele);
          ele = $('<div class="tab-pane" id="' + wrapper + '"><div class="editor" id="ace_' + id.toLowerCase() + '" style="height:300px"></div></div>');
          _this.options_contents.append(ele);
          editor = ace.edit('ace_' + id.toLowerCase());
          editor.setTheme("ace/theme/clouds");
          editor.getSession().setMode("ace/mode/" + _this.ui.modes[1][i]);
          editor.getSession().setUseWrapMode(true);
          editor.setFontSize(14);
          editor.$blockScrolling = Infinity;
          return _this.editor[id] = editor;
        };
      })(this));
      this.options_tabs.children().first().addClass('active');
      this.options_contents.children().first().addClass('active in');
      this.player = null;
      this.playbtns = this.ui.playbtns.map((function(_this) {
        return function(id, i) {
          var ret;
          ret = $(id + '>span.glyphicon');
          ret.on('click', function() {
            return _this.play(i);
          });
          return ret;
        };
      })(this));
      this.reset(options);
      return;
    }

    AppMG.prototype.reset = function(options) {
      var ele, k, len, playbtns, ref, version;
      if (options != null) {
        version = options.version;
        if (version == null) {
          version = "0.1";
        }
        switch (version) {
          case "0.1":
            this.schema = options.schema, this.settings = options.settings, this.contents = options.contents;
            break;
          case "0.2":
            this.schema = options.schema, this.settings = options.settings;
            this.contents = {};
            ref = options.contents;
            for (k = 0, len = ref.length; k < len; k++) {
              ele = ref[k];
              this.contents[ele.mode] = ele.data;
            }
            this.contents.harmony = options.harmony;
        }
        this.obj = options;
      } else {
        this.schema = MG.circularClone(MG.schema_summer);
        this.settings = MG.circularClone(MG.score_summer.settings);
        this.contents = MG.circularClone(MG.score_summer.contents);
        this.obj = null;
      }
      playbtns = this.playbtns;
      this.player = new seqPlayer();
      this.player.onend = function(n) {
        var i;
        i = this.cur_i[n];
        if (i > 0 && i < this.tracks[n].length) {
          return;
        }
        return playbtns[n].toggleClass('glyphicon-play glyphicon-pause');
      };
      return this.updateEditor();
    };

    AppMG.prototype["export"] = function() {
      return {
        version: "0.2",
        settings: this.settings,
        schema: this.schema,
        harmony: this.contents.harmony,
        contents: [
          {
            "mode": "melody",
            "data": this.contents.melody
          }, {
            "mode": "texture",
            "data": this.contents.texture
          }
        ]
      };
    };

    AppMG.prototype.updateEditor = function() {
      return _.flatten(this.ui.editor).forEach((function(_this) {
        return function(e) {
          var ret;
          if (e === 'schema') {
            ret = MG.schema_parser.produce(_this.schema);
          } else if (_this.contents[e] != null) {
            ret = _this.contents[e].join('\n');
          } else {
            ret = JSON.stringify(_this[e], null, 2);
          }
          _this.editor[e].setValue(ret, -1);
        };
      })(this));
    };

    AppMG.prototype.play = function(n) {
      if (!this.player.playing[n]) {
        this.player.play(n);
      } else {
        this.player.pause(n);
      }
      return this.playbtns[n].toggleClass('glyphicon-play glyphicon-pause');
    };

    AppMG.prototype.parse = function() {
      var e, error;
      try {
        this.settings = JSON.parse(this.editor.settings.getValue());
      } catch (error) {
        e = error;
        $.notify('Bad score format!', 'warning');
      }
      ['melody', 'harmony', 'texture'].forEach((function(_this) {
        return function(e) {
          return _this.contents[e] = _this.editor[e].getValue().split(/[\n]+/);
        };
      })(this));
      this.obj = new ScoreObj(this.settings, this.contents);
      this.player.fromScore(this.obj);
      return this.obj;
    };

    AppMG.prototype.generate = function() {
      var generator, score;
      this.settings = JSON.parse(this.editor.settings.getValue());
      this.schema = MG.schema_parser.parse(this.editor.schema.getValue());
      generator = new Generator(this.settings, this.schema);
      generator.generate();
      score = generator.toScoreObj();
      this.contents.melody = score.toText();
      this.contents.harmony = score.harmony_text;
      return this.updateEditor();
    };

    AppMG.prototype.analysis = function(data, ctrl_per_beat) {
      var info, m, obj, q, settings, tracks;
      if (data == null) {
        data = MIDI.Player.currentData;
      }
      if (ctrl_per_beat == null) {
        ctrl_per_beat = 8;
      }
      m = MidiFile(data);
      settings = {
        key_sig: MG.key_sig_rev[m.getKeySignature()[0]],
        time_sig: m.getTimeSignature(),
        ctrl_per_beat: ctrl_per_beat
      };
      q = m.quantize(ctrl_per_beat);
      tracks = q.map(function(track) {
        var delta, res, ret, tmp;
        res = [];
        tmp = [];
        delta = 0;
        track.forEach(function(e) {
          if (e[0] > delta) {
            if (tmp.length > 0) {
              res.push([e[0] - delta, tmp]);
              tmp = [];
            } else {
              res.push([e[0] - delta, [0]]);
            }
            delta = e[0];
          }
          if (e[1] === 'noteOn' && e[3] !== 0) {
            tmp.push(e[2]);
          } else if (e[1] === 'timeSignature') {
            console.log('time_sig change', e);
          } else if (e[1] === 'keySignature') {
            console.log('key_sig change', e);
          }
        });
        res = _.unzip(res);
        res = {
          dur: res[0],
          pitch: res[1]
        };
        ret = Generator.prototype.b2score.call({}, res, ctrl_per_beat * settings.time_sig[0]);
        ret.info = midi_statistics(Generator.prototype.b2score.call({}, res, ctrl_per_beat));
        return ret;
      });
      obj = new ScoreObj(settings);
      obj.setMelody(tracks[0], true);
      obj.setTexture(tracks[1], [], true);
      this.obj = obj;
      this.editor.settings.setValue(JSON.stringify(this.obj.getSettings(), null, 2), -1);
      this.editor.melody.setValue(this.obj.toText().join('\n'), -1);
      info = tracks.map(function(e) {
        return e.info;
      });
      MG.ref_midi_info = info[0];
      return info;
    };

    return AppMG;

  })();

}).call(this);

//# sourceMappingURL=appMG.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, parser, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref = this.MG) != null ? ref : {};

  MG.ref_midi_info = null;

  parser = MG.schema_parser;


  /*
    generating music from schema
   */

  this.Generator = (function() {
    var newChoices, rndPicker, seededRandom;

    function Generator(settings, schema) {
      var base, base1, base2, k, ref1, v;
      this.settings = settings;
      this.schema = schema;
      if ((base = this.settings).key_sig == null) {
        base.key_sig = 'C';
      }
      if ((base1 = this.settings).scale == null) {
        base1.scale = 'maj';
      }
      if ((base2 = this.settings).instrs == null) {
        base2.instrs = [1, 1];
      }
      this.keyref = MG.keyToPitch[this.settings.key_sig + '4'];
      this.scale = MG.scale_class[this.settings.scale];
      this.seeds = {};
      ref1 = this.schema;
      for (k in ref1) {
        v = ref1[k];
        if ((v.mode != null) && v.mode === 'distribution') {
          this.seeds[k] = v;
        }
      }
      this.res = {};
      this.toPitch = MG.scaleToPitch(this.settings.scale, this.settings.key_sig);
      this.toScale = MG.pitchToScale(this.settings.scale, this.settings.key_sig);
    }

    seededRandom = MG.seededRandom;

    Generator.prototype.produce = function(variable, global) {
      var dependency, i, k, l, len, len1, local, m, next_global, ref1, ref2, ret, v;
      if (variable.mode != null) {
        switch (variable.mode) {
          case 'chord':
            console.log('DEPRECATED!!');
            return this.gen_random(variable);
          case 'random':
            return this.gen_random(variable);
          case 'distribution':
            return variable;
          case 'exact':
            return this.gen_exact(variable);
        }
      }
      if (variable.node == null) {
        variable.node = {};
      }
      if (variable.action == null) {
        variable.action = {};
      }
      if (global == null) {
        global = {};
      }
      local = _.keys(variable.node);
      dependency = {};
      ref1 = variable.node;
      for (k in ref1) {
        v = ref1[k];
        dependency[k] = [];
        if (v.mode != null) {
          continue;
        }
        if (v.node == null) {
          v.node = {};
        }
        ref2 = v.structure;
        for (l = 0, len = ref2.length; l < len; l++) {
          i = ref2[l];
          if (!(i in v.node) && indexOf.call(local, i) >= 0) {
            dependency[k].push(i);
          }
        }
      }
      local = MG.top_sort(dependency);
      next_global = Object.assign({}, global);
      for (m = 0, len1 = local.length; m < len1; m++) {
        k = local[m];
        next_global[k] = this.produce(variable.node[k], next_global);
      }
      ret = new Snippet();
      variable.structure.forEach((function(_this) {
        return function(v, i) {
          var options, tmp;
          if (v in next_global) {
            tmp = next_global[v];
            if (("_" + i + "_" + v) in variable.action) {
              options = variable.action["_" + i + "_" + v];
              console.log('ACT', options.mode);
              switch (options.mode) {
                case 'transpose':
                  tmp = _this.act_transpose(options, tmp);
                  break;
                case 'reverse':
                  tmp = _this.act_reverse(options, tmp);
                  break;
                case 'dim':
                  tmp = _this.act_dim(options, tmp);
                  break;
                case 'aug':
                  tmp = _this.act_aug(options, tmp);
              }
            }
            ret = ret.join(tmp, {
              smooth: 'true'
            });
            return console.log('concat', v, ret.data.length);
          } else {
            return console.log('miss', v);
          }
        };
      })(this));
      return ret;
    };

    Generator.prototype.generate = function() {
      var res, res_eval, sec;
      sec = this.settings.ctrl_per_beat * this.settings.time_sig[0];
      res_eval = [];
      this.snippet = this.produce(this.schema.S);
      this.snippet.cadence(this.settings.key_sig);
      console.log(this.snippet);
      this.res2 = this.snippet.toScore(this.settings.key_sig);
      console.log(this.res2);
      res = this.res2;
      return res;
    };

    Generator.prototype.evaluate = function(data) {
      var info, info_dur, r_all, ref_beat_dur, report;
      info = MG.midi_statistics(data);
      console.log('eval', data, info);
      report = {};
      if (info.rhythm.length === 0) {
        return;
      }
      r_all = 0;
      info.rhythm.forEach(function(e) {
        return r_all += e[1];
      });
      report.simp = info.rhythm[0][1] / r_all;
      report.range = _.max(info.range);
      console.log('report', report.simp, report.range);
      if (MG.ref_midi_info !== null) {
        ref_beat_dur = math.sum(MG.ref_midi_info.rhythm[0][0].split(','));
        info_dur = math.sum(info.rhythm[0][0].split(','));
        console.log('compare', info_dur, ref_beat_dur);
      }
      return info;
    };

    newChoices = function(pre, choices, weights) {
      var ret;
      ret = {};
      choices.forEach(function(e, i) {
        ret[pre + e] = weights[i];
      });
      return ret;
    };

    Generator.prototype.act_transpose = function(options, acted) {
      var cur_i, dur, interval, refd, res, src, tmp, transpose;
      dur = options.dur;
      res = new Snippet();
      src = acted.data;
      transpose = MG.transposer(options.scale, this.settings.key_sig);
      interval = options.interval;
      if (typeof interval === 'number') {
        interval = [interval];
      }
      refd = 0;
      cur_i = 0;
      while (dur > 0) {
        if (refd >= src.length) {
          refd -= src.length;
          cur_i = (cur_i + 1) % interval.length;
          console.log('shift to next interval');
        }
        tmp = new Measure(src[0].time_sig, src[0].tatum);
        tmp.harmony = MG.clone(src[refd].harmony);
        tmp.harmony.forEach(function(e) {
          return e[1] = transpose(e[1], interval[cur_i]);
        });
        src[refd].dur.forEach(function(e, i) {
          if (dur - e >= 0) {
            tmp.dur.push(e);
            tmp.pitch.push(transpose(src[refd].pitch[i], interval[cur_i]));
            dur -= e;
          } else if (dur > 0) {
            tmp.dur.push(dur);
            tmp.pitch.push(transpose(src[refd].pitch[i], interval[cur_i]));
            dur = 0;
          }
        });
        res.data.push(tmp);
        refd++;
      }
      console.log(acted, 'transpose-> ', res);
      return res;
    };

    Generator.prototype.act_reverse = function(options, acted) {
      var res;
      res = acted.copy();
      if ((options.deep != null) && options.deep === true) {
        res.data.reverse().forEach(function(arr) {
          arr.pitch.reverse();
          arr.dur.reverse();
          if (arr.harmony != null) {
            return arr.harmony.reverse();
          }
        });
      } else {
        res.data.reverse();
      }
      console.log(acted, 'reverse-> ', res);
      return res;
    };

    Generator.prototype.act_aug = function(options, acted) {};

    Generator.prototype.act_dim = function(options, acted) {};

    Generator.prototype.gen_exact = function(options) {
      var res;
      return res = MG.parseMelody(options.score, options);
    };

    Generator.prototype.gen_random = function(options) {
      var bass, choices, chorder, cur_chord, dur, harmony, i, j, k, n, new_dur, op, pre, pre2, range, range_dist, raw_choices, rc1, rc2, res, scale_len, seed, seed2, swarp, tmp, toPitch, toScale, v;
      dur = options.dur;
      toPitch = this.toPitch;
      toScale = this.toScale;
      harmony = MG.parseHarmony(options.chords, this.settings.key_sig, this.settings.time_sig[0] * this.settings.ctrl_per_beat);
      chorder = MG.harmony_progresser(harmony);
      scale_len = this.scale.length;
      res = {
        dur: [],
        pitch: []
      };
      seed = {};
      if ((options.rhythm.seed != null) && (this.seeds != null)) {
        seed = this.seeds[options.rhythm.seed];
      } else {
        seed.dur = options.rhythm[0];
        seed.choices = options.rhythm[1];
        seed.weights = options.rhythm[2];
      }
      seed2 = {};
      if ((options.interval.seed != null) && (this.seeds != null)) {
        seed2 = this.seeds[options.interval.seed];
      } else {
        seed2 = options.interval;
      }
      range = options.range;
      if (range == null) {
        range = [48, 90];
      }
      range_dist = function(k) {
        if (k < range[0] || k > range[1]) {
          return 0;
        } else {
          return 0.25 + 3 * (k - range[0]) * (range[1] - k) / Math.pow(range[1] - range[0], 2);
        }
      };
      if ((options.dist != null) && options.dist === 'linear') {
        range_dist = function(k) {
          if (k < range[0] || k > range[1]) {
            return 0;
          } else {
            return 1 - 2 * Math.abs(k - (range[0] + range[1]) / 2) / (range[1] - range[0]);
          }
        };
      }
      swarp = options.rhythm.swarp;
      if (swarp == null) {
        swarp = 1;
      }
      n = Math.floor(dur / (seed.dur / swarp));
      rc1 = rndPicker(seed.choices, seed.weights);
      pre = scale_len * 4;
      pre2 = pre;
      i = 0;
      while (i < n) {
        new_dur = rc1.gen().map(function(d) {
          return Math.floor(d / swarp);
        });
        res.dur.push(new_dur);
        tmp = [];
        j = 0;
        while (j < res.dur[i].length) {
          chorder.process();
          cur_chord = chorder.chord();
          bass = chorder.bass();
          raw_choices = newChoices(pre, seed2.choices, seed2.weights);
          choices = {};
          for (k in raw_choices) {
            v = raw_choices[k];
            if (k >= 0 && k <= scale_len * 8) {
              k = toPitch(k);
              v *= range_dist(k);
              if (options.chord_tone != null) {
                cur_chord.forEach(function(ee, ii) {
                  if (modulo(k - bass, 12) === ee) {
                    return v *= options.chord_tone;
                  }
                });
              }
              if (options.scale_tone != null) {
                console.log('scale tone');
              }
              choices[k] = v;
            }
          }
          rc2 = rndPicker(_.keys(choices), _.values(choices));
          pre = parseInt(rc2.gen());
          tmp.push(pre);
          pre = toScale(pre);
          pre = pre[0] + pre[1] * scale_len;
          chorder.forward(res.dur[i][j]);
          ++j;
        }
        res.pitch.push(tmp);
        ++i;
      }
      op = {
        time_sig: this.settings.time_sig,
        tatum: this.settings.ctrl_per_beat
      };
      if (options.incomplete_start != null) {
        op.incomplete_start = options.incomplete_start;
      }
      harmony.forEach(function(e1) {
        return e1.forEach(function(e) {
          return e[2] = MG.chord_finder[e[2].toString()] || 'maj';
        });
      });
      return res = new Snippet(res.pitch, res.dur, harmony, op);
    };

    Generator.prototype.b2score = function(b, sec) {
      var delta, dur, pitch, ret, tmp;
      dur = _.flatten(b.dur, true);
      pitch = _.flatten(b.pitch, true);
      ret = [];
      tmp = [];
      delta = 0;
      dur.forEach(function(e, j) {
        while (delta + e > sec) {
          tmp.push([sec - delta, pitch[j], true]);
          ret.push(tmp);
          tmp = [];
          e -= sec - delta;
          delta = 0;
        }
        tmp.push([e, pitch[j]]);
        delta += e;
        if (delta === sec) {
          ret.push(tmp);
          tmp = [];
          return delta = 0;
        }
      });
      if (tmp.length > 0) {
        ret.push(tmp);
      }
      return ret;
    };

    Generator.prototype.toScoreObj = function() {
      var harmony, melody, obj, res;
      if (_.keys(this.res2).length === 0) {
        this.generate();
      }
      res = this.res2;
      harmony = this.res2.map(function(e) {
        return e.harmony;
      });
      obj = new ScoreObj(this.settings);
      melody = res;
      melody.info = {
        time_sigs: {
          0: this.settings.time_sig
        },
        key_sigs: {
          0: this.settings.key_sig
        },
        tempi: {
          0: this.settings.tempo
        }
      };
      obj.setMelody(melody, true);
      obj.harmony_text = harmony;
      return obj;
    };

    rndPicker = function(choices, weights) {
      var i, l, p, ref1, s;
      s = weights.reduce((function(a, b) {
        return a + b;
      }), 0);
      p = weights.map(function(e) {
        return e / s;
      });
      s = 0;
      for (i = l = 0, ref1 = p.length; l < ref1; i = l += 1) {
        s = (p[i] += s);
      }
      return {
        gen: function() {
          var m, r, ref2;
          r = seededRandom();
          for (i = m = 0, ref2 = p.length; m < ref2; i = m += 1) {
            if (r < p[i]) {
              return choices[i];
            }
          }
          return choices[p.length - 1];
        }
      };
    };

    return Generator;

  })();

}).call(this);

//# sourceMappingURL=Generator.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, parser, ref,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref = this.MG) != null ? ref : {};

  parser = MG.score_parser;


  /*
    measure with data(pitch, dur) and properties
   */

  this.Measure = (function() {
    function Measure(time_sig1, tatum1) {
      this.time_sig = time_sig1;
      this.tatum = tatum1;
      this.pitch = [];
      this.dur = [];
      if (this.time_sig == null) {
        this.time_sig = [4, 4];
      }
      if (this.tatum == null) {
        this.tatum = 8;
      }
    }

    Measure.prototype.copy = function(measure) {
      if (arguments.length === 0) {
        measure = new Measure(MG.clone(this.time_sig), this.tatum);
        measure.pitch = MG.clone(this.pitch);
        measure.dur = MG.clone(this.dur);
        MG.condCopy(this, measure, ['tie', 'incomplete_start', 'harmony']);
        return measure;
      }
      this.time_sig = MG.clone(measure.time_sig);
      this.tatum = measure.tatum;
      this.pitch = MG.clone(measure.pitch);
      this.dur = MG.clone(measure.dur);
      return MG.condCopy(measure, this, ['tie', 'incomplete_start', 'harmony']);
    };

    Measure.prototype.add = function(pitch, dur) {
      this.pitch.push(pitch);
      this.dur.push(dur);
    };

    Measure.prototype.note = function(i) {
      return [this.dur[i], this.pitch[i]];
    };

    Measure.prototype.last = function() {
      return this.note(this.len() - 1);
    };

    Measure.prototype.first = function() {
      return this.note(0);
    };

    Measure.prototype.setNote = function(i, note) {
      this.dur[i] = note[0];
      return this.pitch[i] = note[1];
    };

    Measure.prototype.len = function() {
      return this.dur.length;
    };

    Measure.prototype.incomplete = function() {
      return math.sum(this.dur) < this.tatum * this.time_sig[0];
    };

    Measure.prototype.overflow = function() {
      return math.sum(this.dur) > this.tatum * this.time_sig[0];
    };

    Measure.prototype.pos = function(beat, tatum) {
      var d_i, offset;
      if (this.dur.length === 0) {
        return null;
      }
      if (tatum == null) {
        tatum = 0;
      }
      offset = beat * this.tatum + tatum;
      d_i = 0;
      while (d_i < this.dur.length && offset > 0) {
        offset -= this.dur[d_i];
        d_i++;
      }
      if (offset < 0) {
        d_i--;
      }
      if (d_i >= this.dur.length) {
        d_i = this.dur.length - 1;
      }
      return this.pitch[d_i];
    };

    return Measure;

  })();


  /*
    snippet
    data: array of measures
   */

  this.Snippet = (function() {
    function Snippet(pitch, dur, harmony, options) {
      var delta, m_i, measure, ref1, ref2, ref3, res, sec, tatum, time_sig;
      if (arguments.length === 0) {
        this.data = [];
        return;
      }
      while (typeof dur[0] !== 'number') {
        dur = _.flatten(dur, true);
        pitch = _.flatten(pitch, true);
      }
      tatum = (ref1 = options.tatum) != null ? ref1 : 8;
      time_sig = (ref2 = options.time_sig) != null ? ref2 : [4, 4];
      sec = tatum * time_sig[0];
      MG.condCopy(options, this, ['incomplete_start', 'tie']);
      delta = (ref3 = this.incomplete_start) != null ? ref3 : sec;
      m_i = 0;
      console.log(harmony.length, 'harmony length');
      measure = new Measure(time_sig, tatum);
      res = [];
      dur.forEach((function(_this) {
        return function(e, i) {
          var results;
          if (delta - e >= 0) {
            measure.pitch.push(pitch[i]);
            measure.dur.push(e);
            delta -= e;
            if (delta === 0) {
              measure.harmony = harmony[m_i];
              res.push(measure);
              m_i++;
              measure = new Measure(time_sig, tatum);
              return delta = sec;
            }
          } else {
            results = [];
            while (delta < e) {
              measure.dur.push(delta);
              measure.pitch.push(pitch[i]);
              measure.tie = true;
              measure.harmony = harmony[m_i];
              res.push(measure);
              e -= delta;
              delta = sec;
              measure = new Measure(time_sig, tatum);
              results.push(m_i++);
            }
            return results;
          }
        };
      })(this));
      if (delta < sec) {
        this.incomplete_end = sec - delta;
        measure.harmony = harmony[m_i];
        res.push(measure);
      }
      this.data = res;
      return;
    }

    Snippet.prototype.last = function() {
      if (this.data.length === 0) {
        return null;
      }
      return this.data[this.data.length - 1];
    };

    Snippet.prototype.first = function() {
      if (this.data.length === 0) {
        return null;
      }
      return this.data[0];
    };

    Snippet.prototype.copy = function(s) {
      if (arguments.length === 0) {
        s = new Snippet();
        s.data = this.data.map(function(e) {
          return e.copy();
        });
        MG.condCopy(this, s, ['incomplete_start', 'tie']);
        return s;
      }
      this.data = s.data.map(function(e) {
        return e.copy();
      });
      return MG.condCopy(s, this, ['incomplete_start', 'tie']);
    };

    Snippet.prototype.join = function(s, modify) {
      var first_measure, first_note, last_measure, last_note, measure, pre_note, ret, tmp;
      ret = this.copy();
      s = s.copy();
      if (ret.data.length > 0) {
        if ((modify != null) && (modify.smooth != null)) {
          last_measure = ret.last();
          first_measure = s.first();
          console.log('new smooth', last_measure, first_measure);
          last_note = last_measure.last();
          first_note = first_measure.first();
          if (last_measure.len() > 1) {
            pre_note = last_measure.note(last_measure.len() - 2);
            if ((last_note[1] > pre_note[1] && last_note[1] > first_note[1]) || (last_note[1] < pre_note[1] && last_note[1] < first_note[1])) {
              last_measure.setNote(last_measure.len() - 2, last_note);
              last_note = pre_note;
              pre_note = last_measure.note(last_measure.len() - 2);
            }
          }
          if (last_note[1] - first_note[1] <= -12) {
            last_note[1] += 12;
          } else if (last_note[1] - first_note[1] >= 12) {
            last_note[1] -= 12;
          }
          last_measure.setNote(last_measure.len() - 1, last_note);
          console.log('smooth', last_measure, first_measure);
        }
        tmp = ret.data.pop();
        measure = null;
        if ((this.incomplete_end != null) && (s.incomplete_start != null)) {
          measure = new Measure();
          measure.harmony = MG.clone(tmp.harmony);
          if (measure.harmony == null) {
            measure.harmony = [];
          }
          measure.pitch = tmp.pitch.concat(s.data[0].pitch);
          measure.dur = tmp.dur.concat(s.data[0].dur);
          if (s.data[0].harmony != null) {
            measure.harmony = measure.harmony.concat(s.data[0].harmony);
          }
          if ((s.data[0].tie != null) && s.data[0].tie === true) {
            measure.tie = s.data[0].tie;
          }
          s.data.shift();
        } else {
          measure = tmp.copy();
        }
        ret.data.push(measure);
      }
      ret.data = ret.data.concat(s.data);
      MG.condCopy(s, ret, ['incomplete_end']);
      return ret;
    };

    Snippet.prototype.cadence = function(key) {
      var adjust, last_measure, last_note, pre_note, tonic;
      last_measure = this.last();
      last_measure.dur.sort();
      tonic = MG.key_class[key];
      last_note = last_measure.last();
      adjust = modulo(tonic - (last_note[1] % 12), 12);
      if (adjust > 6) {
        adjust -= 12;
      }
      last_note[1] += adjust;
      console.log(adjust, 'adjust->', last_note);
      if (last_measure.len() > 1) {
        pre_note = last_measure.note(last_measure.len() - 2);
        if (last_note[1] - pre_note[1] >= 12) {
          last_note[1] -= 12;
        }
        if (last_note[1] === pre_note[1]) {
          return;
        }
      }
      return last_measure.setNote(last_measure.len() - 1, last_note);
    };

    Snippet.prototype.toScore = function(key_sig) {
      var sharp;
      if (key_sig == null) {
        key_sig = 'C';
      }
      sharp = MG.key_sig[key_sig] >= 0;
      return this.data.map(function(measure) {
        var durs, gcd, ret;
        ret = _.zip(measure.dur, measure.pitch);
        if ((measure.tie != null) && (measure.tie = true)) {
          ret[ret.length - 1].push(true);
        }
        durs = measure.harmony.map(function(e) {
          return e[0];
        });
        gcd = MG.gcd.apply(null, durs);
        if (gcd > 1) {
          measure.harmony.forEach(function(e) {
            return e[0] /= gcd;
          });
        }
        ret.harmony = (measure.harmony.map(function(e) {
          var tmp;
          tmp = MG.pitchToKey(e[1], sharp, true) + e[2];
          if (e[0] > 1) {
            tmp += ',' + e[0];
          }
          return tmp;
        })).join(' ');
        return ret;
      });
    };

    return Snippet;

  })();


  /*
    score object, with tracks and settings
    one track is an array of measure, with property
   */

  this.ScoreObj = (function() {
    function ScoreObj(options, contents) {
      if (options == null) {
        options = {};
      }
      this.tempo = options.tempo, this.time_sig = options.time_sig, this.key_sig = options.key_sig, this.ctrl_per_beat = options.ctrl_per_beat, this.scale = options.scale, this.volumes = options.volumes, this.instrs = options.instrs;
      if (this.tempo == null) {
        this.tempo = 120;
      }
      if (this.time_sig == null) {
        this.time_sig = [4, 4];
      }
      if (this.key_sig == null) {
        this.key_sig = 'C';
      }
      if (this.ctrl_per_beat == null) {
        this.ctrl_per_beat = 4;
      }
      if (this.scale == null) {
        this.scale = 'maj';
      }
      if (this.volumes == null) {
        this.volumes = [110, 80];
      }
      if (this.instrs == null) {
        this.instrs = [1, 1];
      }
      this.init_ref = MG.scaleToPitch(this.scale, this.key_sig)(4 * MG.scale_class[this.scale].length);
      this.init_ctrlTicks = (60000.0 / this.tempo / this.ctrl_per_beat) >>> 0;
      this.tracks = [];
      this.harmony = [];
      this.harmony_text = [];
      if (contents != null) {
        if (contents.melody != null) {
          this.setMelody(contents.melody, false);
        }
        if ((contents.harmony != null) && (contents.texture != null)) {
          this.harmony_text = contents.harmony;
          this.setTexture(contents.texture, contents.harmony);
        }
      }
    }

    ScoreObj.prototype.getSettings = function() {
      return {
        tempo: this.tempo,
        time_sig: this.time_sig,
        key_sig: this.key_sig,
        ctrl_per_beat: this.ctrl_per_beat,
        scale: this.scale,
        volumes: this.volumes,
        instrs: this.instrs
      };
    };

    ScoreObj.prototype.setTrack = function(i, track) {
      if (i > this.tracks.length) {
        console.log('track number overflow');
      }
      return this.tracks[i] = track;
    };

    ScoreObj.prototype.setMelody = function(melody, parsed) {
      var options;
      if ((parsed != null) && parsed === true) {
        return this.setTrack(0, melody);
      } else {
        options = this.getSettings();
        options.scale = MG.scale_class[options.scale];
        options.init_ref = this.init_ref;
        return this.setTrack(0, MG.parseMelody(melody, options));
      }
    };

    ScoreObj.prototype.setTexture = function(texture, harmony, parsed) {
      var options;
      if ((parsed != null) && parsed === true) {
        this.harmony = harmony;
        return this.setTrack(1, texture);
      } else {
        this.harmony = MG.parseHarmony(harmony, this.key_sig, this.ctrl_per_beat * this.time_sig[0]);
        options = this.getSettings();
        options.harmony = this.harmony;
        return this.setTrack(1, MG.parseMelody(texture, options));
      }
    };

    ScoreObj.prototype.setPercussion = function(percussion, parsed) {};

    ScoreObj.prototype.toText = function(m) {
      var ref_oct, res, toScale;
      console.log('to score text');
      if (m == null) {
        m = MG.clone(this.tracks[0]);
      }
      if (m == null) {
        console.log('null melody');
        return;
      }
      toScale = MG.pitchToScale(this.scale, this.key_sig);
      ref_oct = 4;
      res = m.map(function(e) {
        var durs, gcd, ret;
        ret = [];
        durs = e.map(function(e1) {
          return e1[0];
        });
        gcd = MG.gcd.apply(null, durs);
        if (gcd > 1) {
          e.forEach(function(e1) {
            e1[0] /= gcd;
          });
        }
        e.forEach(function(e1) {
          var o;
          o = '';
          if (typeof e1[1] !== 'object') {
            e1[1] = [e1[1]];
          }
          e1[1].forEach(function(e2) {
            var diff, tmp;
            if (e2 < 21 || e2 > 108) {
              return o += '0';
            } else {
              tmp = toScale(e2);
              diff = tmp[1] - ref_oct;
              if (diff < -1 || diff > 1) {
                o += ':';
                while (diff < -1) {
                  o += '-';
                  ref_oct--;
                  diff++;
                }
                while (diff > 1) {
                  o += '+';
                  ref_oct++;
                  diff--;
                }
                o += ' ';
              }
              o += 1 + tmp[0];
              o += {
                '-1': '-',
                1: '+'
              }[diff] || '';
              return o += {
                1: '#',
                2: '##'
              }[tmp[2]] || '';
            }
          });
          if (e1[2] === true) {
            e1[0] = (e1[0] + '^').replace('^^', '^');
          }
          if (typeof e1[0] === 'string' || e1[0] > 1) {
            o += ',' + e1[0];
          }
          return ret.push(o);
        });
        return ret.join(' ');
      });
      return res;
    };

    ScoreObj.prototype.harmony_roman = function() {
      var ex, toRoman;
      toRoman = MG.keyToRoman(this.key_sig);
      ex = /[A-G][b#]{0,2}/;
      this.harmony_text = this.harmony_text.map(function(e, i) {
        return e.split(/\s+/).map(function(e2) {
          var r;
          r = ex.exec(e2);
          if (r === null) {
            return e2;
          } else {
            return e2.replace(r[0], toRoman(r[0])).replace(/b#/g, '').replace(/#b/g, '');
          }
        }).join(' ');
      });
      return this.harmony_text.join('\n');
    };

    ScoreObj.prototype.toMidi = function() {
      var ctrlTicks, delta, dur, e, i, j, m, nTrack, notes, ref1, ref2, t, t_i, vol;
      ctrlTicks = this.init_ctrlTicks;
      m = new simpMidi();
      m.setTimeSignature.apply(m, this.time_sig);
      m.setKeySignature(MG.key_sig[this.key_sig], 'maj');
      m.setTempo(this.tempo);
      m.setDefaultTempo(this.tempo);
      nTrack = this.tracks.length;
      if (nTrack > 9) {
        nTrack = 9;
      }
      for (t_i = j = 0, ref1 = nTrack; j < ref1; t_i = j += 1) {
        if (t_i !== 0) {
          m.addTrack();
          console.log('add track', t_i);
        }
        delta = 0;
        t = _.flatten(this.tracks[t_i], true);
        vol = (ref2 = this.volumes[t_i]) != null ? ref2 : this.volumes[0];
        MIDI.programChange(t_i, this.instrs[t_i] - 1);
        m.addEvent(t_i + 1, 0, 'programChange', t_i, this.instrs[t_i] - 1);
        i = 0;
        while (i < t.length) {
          e = t[i];
          notes = [];
          if (typeof e[1] === 'number') {
            if (e[1] >= 21 && e[1] <= 108) {
              notes.push = e[1];
            }
          } else {
            e[1].forEach(function(pitch) {
              if (pitch >= 21 && pitch <= 108) {
                return notes.push(pitch);
              }
            });
          }
          if (notes.length === 0) {
            delta += e[0];
          } else {
            dur = e[0];
            while (t[i][2] === true && i + 1 < t.length) {
              dur += t[++i][0];
            }
            m.addNotes(t_i + 1, dur * ctrlTicks, notes, vol, 0, delta * ctrlTicks);
            delta = 0;
          }
          ++i;
        }
      }
      m.finish();
      return m;
    };

    return ScoreObj;

  })();

}).call(this);

//# sourceMappingURL=ScoreObj.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  this.ScoreRenderer = (function() {
    var dur_obj, toBit;

    function ScoreRenderer(c, p) {
      var pager;
      this.c = document.getElementById(c);
      this.real_ctx = this.c.getContext('2d');
      this.hidden_canvas = document.createElement('canvas');
      this.r = new Vex.Flow.Renderer(this.hidden_canvas, Vex.Flow.Renderer.Backends.CANVAS);
      this.ctx = this.r.getContext();
      this.geo = {
        system_width: 900,
        system_height: 80,
        system_interval: 50,
        left_padding: 30,
        top_padding: 70,
        reserved_width: 55
      };
      this.layout = {
        measure_per_system: 4,
        system_per_page: 5
      };
      this.numPage = 1;
      this.currentPage = 1;
      this.measures = [];
      this.pages = [];
      pager = $('#midi_pager');
      this.UI = {
        prev: pager.find('.prev'),
        next: pager.find('.next'),
        page_num: pager.find('.page_num'),
        page_count: pager.find('.page_count')
      };
      this.UI.prev.on('click', (function(_this) {
        return function() {
          if (_this.currentPage <= 1) {
            return;
          }
          _this.currentPage--;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      this.UI.next.on('click', (function(_this) {
        return function() {
          if (_this.currentPage >= _this.numPage) {
            return;
          }
          _this.currentPage++;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      if (p != null) {
        this.p = new fabric.StaticCanvas(p, {
          width: $('.canvas-wrapper').width(),
          height: $('.canvas-wrapper').width() * 2,
          backgroundColor: 'rgba(240,250,240, 5)'
        });
      }
    }

    ScoreRenderer.prototype.newStave = function(m, clef) {
      var i, j, w, x, y;
      if (clef == null) {
        clef = 'treble';
      }
      i = m % this.layout.measure_per_system;
      j = (Math.floor(m / this.layout.measure_per_system)) % this.layout.system_per_page;
      w = Math.floor(this.geo.system_width / this.layout.measure_per_system);
      x = this.geo.left_padding + i * w;
      y = this.geo.top_padding + j * (this.geo.system_height + this.geo.system_interval);
      if (i === 0) {
        return new Vex.Flow.Stave(x, y, w).addClef(clef);
      } else {
        return new Vex.Flow.Stave(x, y, w);
      }
    };

    toBit = function(i) {
      var j, res;
      res = [];
      j = 1;
      while (i > 0) {
        if ((j & i) > 0) {
          res.unshift(j);
          i -= j;
        }
        j <<= 1;
      }
      return res;
    };

    ScoreRenderer.prototype.toBit = toBit;

    dur_obj = function(sum, dur) {
      var i, p, r, r1, remain, ret, ret2, rs;
      if (sum === 0) {
        return {
          sum: dur,
          dur: toBit(dur)
        };
      }
      r = toBit(sum + dur);
      p = 0;
      r1 = r.map(function(e) {
        return p += e;
      });
      i = 0;
      while (sum > r1[i]) {
        i++;
      }
      ret = r.slice(i + 1);
      remain = r1[i] - sum;
      if (remain === 0) {
        return {
          sum: sum + dur,
          dur: ret
        };
      }
      rs = toBit(sum);
      rs = rs.slice(i);
      ret2 = [];
      while (remain > 0) {
        ret2.push(rs[rs.length - 1]);
        remain -= ret2[ret2.length - 1];
        rs[rs.length - 1] *= 2;
        while (rs.length > 1 && rs[rs.length - 1] === rs[rs.length - 2]) {
          rs.pop();
          rs[rs.length - 1] *= 2;
        }
      }
      ret = ret2.concat(ret);
      return {
        sum: dur + sum,
        dur: ret
      };
    };

    ScoreRenderer.prototype.renderPage = function(num) {
      var c, ctx, e, formatter, i, k, last, ref, ref1, start;
      if (num < 0 || num >= this.numPage) {
        return;
      }
      if (this.pages[num] != null) {
        this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
        this.real_ctx.drawImage(this.pages[num], 0, 0);
        this.UI.page_num.html(num + 1);
        return;
      }
      console.log('render page', num + 1);
      this.r.resize(1000, 800);
      this.c.width = 1000;
      this.c.height = 800;
      start = this.layout.measure_per_system * this.layout.system_per_page;
      last = (num + 1) * start;
      start = last - start;
      if (last >= this.measures.length) {
        last = this.measures.length;
      }
      ctx = this.ctx;
      for (i = k = ref = start, ref1 = last; k < ref1; i = k += 1) {
        e = this.measures[i];
        formatter = new Vex.Flow.Formatter().joinVoices(e.voices).format(e.voices, e.w);
        e.stave.setContext(ctx).draw();
        e.voices.forEach(function(v) {
          return v.draw(ctx, e.stave);
        });
        e.beams.forEach(function(v) {
          return v.setContext(ctx).draw();
        });
        e.ties.forEach(function(v) {
          return v.setContext(ctx).draw();
        });
      }
      c = document.createElement('canvas');
      c.width = 1000;
      c.height = 800;
      c.getContext('2d').drawImage(this.hidden_canvas, 0, 0);
      this.pages[num] = c;
      this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
      this.real_ctx.drawImage(this.pages[num], 0, 0);
      return this.UI.page_num.html(num + 1);
    };

    ScoreRenderer.prototype.render = function(s) {
      var add_key_sig, beams, err, error, i, k, key_sig, later_tie, melody, notes, num_beats, ref, sharp, stave, sum, ties, time_sig, toScale, voice, w;
      this.s = s;
      this.layout.measure_per_system = s.ctrl_per_beat > 16 ? 2 : 3;
      this.measures = [];
      melody = s.tracks[0];
      time_sig = melody.info.time_sigs[0] = s.time_sig;
      key_sig = melody.info.key_sigs[0] = s.key_sig;
      sharp = MG.key_sig[key_sig] >= 0;
      toScale = MG.pitchToScale(s.scale, key_sig);
      this.geo.reserved_width = 30 + 5 * Math.abs(MG.key_sig[key_sig]);
      for (i = k = 0, ref = melody.length; k < ref; i = k += 1) {
        stave = this.newStave(i);
        add_key_sig = false;
        w = Math.floor(this.geo.system_width / this.layout.measure_per_system);
        if (melody.info.key_sigs[i] != null) {
          key_sig = melody.info.key_sigs[i];
          sharp = MG.key_sig[key_sig] >= 0;
          toScale = MG.pitchToScale(s.scale, key_sig);
          console.log('key_sig change', key_sig);
          add_key_sig = true;
        }
        if (add_key_sig || i % this.layout.measure_per_system === 0) {
          this.geo.reserved_width = 28 + 6 * Math.abs(MG.key_sig[key_sig]);
          stave.addKeySignature(key_sig);
          w -= this.geo.reserved_width;
        }
        if (melody.info.time_sigs[i] != null) {
          time_sig = melody.info.time_sigs[i];
          stave.addTimeSignature(time_sig.join('/'));
          w -= 20;
        }
        notes = [];
        ties = [];
        later_tie = [];
        sum = 0;
        melody[i].forEach(function(e) {
          var dur, durs, ii, indices, keys, l, pd, ref1, ref2, rest, start, tie;
          ref1 = dur_obj(sum, 16 * e[0] / s.ctrl_per_beat), sum = ref1.sum, dur = ref1.dur;
          durs = [];
          pd = 0;
          dur.forEach(function(d) {
            if (d === pd) {
              durs[durs.length - 1] += 'd';
            } else {
              durs.push('' + (16 * time_sig[1] / d));
            }
            return pd = d / 2;
          });
          keys = [];
          if (typeof e[1] === 'number') {
            e[1] = [e[1]];
          }
          e[1].forEach(function(e1) {
            var key, tmp;
            if (e1 < 21 || e1 > 108) {
              return;
            }
            tmp = toScale(e1);
            key = MG.scale_keys[key_sig][tmp[0]];
            key += '/' + ((Math.floor(e1 / 12)) - 1 + ({
              'Cb': 1,
              'B#': -1
            }[key] || 0));
            if (tmp[2] !== 0) {
              key = MG.pitchToKey(e1, sharp).join('/');
            }
            if (key != null) {
              return keys.push(key);
            }
          });
          rest = false;
          if (keys.length <= 0) {
            rest = true;
            keys.push('Bb/4');
            durs = durs.map(function(d) {
              return d + 'r';
            });
          }
          durs.forEach(function(d) {
            var iii, l, r, ref2, res;
            res = new Vex.Flow.StaveNote({
              keys: keys,
              duration: d,
              auto_stem: true
            });
            r = /d+/.exec(d);
            if (r != null) {
              for (iii = l = 0, ref2 = r[0].length; l < ref2; iii = l += 1) {
                res.addDotToAll();
              }
            }
            return notes.push(res);
          });
          if (!rest && durs.length > 1) {
            start = notes.length - durs.length;
            indices = Array(keys.length).fill(0).map(function(ee, index) {
              return index;
            });
            for (ii = l = 1, ref2 = durs.length; l < ref2; ii = l += 1) {
              tie = new Vex.Flow.StaveTie({
                first_note: notes[start + ii - 1],
                last_note: notes[start + ii],
                first_indices: indices,
                last_indices: indices
              });
              ties.push(tie);
            }
          }
          if (e[2] === true) {
            return later_tie.push(notes.length - 1);
          }
        });
        later_tie.forEach(function(ii) {
          var indices, tie;
          indices = Array(notes[ii].keys.length).fill(0).map(function(ee, index) {
            return index;
          });
          tie = new Vex.Flow.StaveTie({
            first_note: notes[ii],
            last_note: notes[ii + 1],
            first_indices: indices,
            last_indices: indices
          });
          ties.push(tie);
        });
        num_beats = Math.floor(sum / 16);
        voice = new Vex.Flow.Voice({
          num_beats: num_beats,
          beat_value: time_sig[1],
          resolution: Vex.Flow.RESOLUTION
        });
        try {
          voice.addTickables(notes);
        } catch (error) {
          err = error;
          console.log(err.message);
          continue;
        }
        Vex.Flow.Accidental.applyAccidentals([voice], key_sig);
        beams = Vex.Flow.Beam.applyAndGetBeams(voice);
        if (i % this.layout.measure_per_system === 0) {
          w -= 20;
        }
        this.measures.push({
          w: w - 10,
          voices: [voice],
          stave: stave,
          beams: beams,
          ties: ties
        });
      }
      this.numPage = Math.ceil(this.measures.length / this.layout.measure_per_system / this.layout.system_per_page);
      this.UI.page_count.html(this.numPage);
      this.currentPage = 1;
      this.pages.forEach((function(_this) {
        return function(c, i) {
          return delete _this.pages[i];
        };
      })(this));
      this.pages = [];
      return this.renderPage(this.currentPage - 1);
    };

    return ScoreRenderer;

  })();

}).call(this);

//# sourceMappingURL=ScoreRenderer.js.map
;function dataURLtoBlob(dataurl) {
	var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
			bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
	while(n--){
		u8arr[n] = bstr.charCodeAt(n);
	}
	return new Blob([u8arr], {type:mime});
}


var TEST = TEST || {};



function midi_statistics(obj){
	function obj_sort(data){
		var k = Object.keys(data);
		var v = k.map(function(key){return data[key]});
		var kv = _.zip(k,v);
		kv.sort(function(a,b){return b[1]-a[1]});// decending
		return kv;
	}
	var info = {rhythm:{}, melody:{one:{}, two:{}}};
	var one = {}, two = {};
	var n_one = 0, n_two = 0;
	obj.forEach(function(e){
		var measure = _.unzip(e);
		var r = measure[0];
		info.rhythm[r] = 1+ (info.rhythm[r] || 0);
		r = measure[1];
		if(r.length<2) return;
		var c = [r[0] % 12, (r[1]-r[0])%12];
		one[c] = 1+ (one[c] || 0); n_one ++;
		for(var i=2;i < r.length;++i){
			c = [r[i-1]%12, (r[i]-r[i-1])%12];
			one[c] = 1 + (one[c]||0); n_one ++;
			c = [r[i-2] % 12, (r[i-1] - r[i-2]) % 12, c[1]];
			two[c] = 1 + (two[c]||0); n_two ++;
		}
	});

	info = {
		rhythm: obj_sort(info.rhythm),
		melody: {
			one: obj_sort(one),
			two: obj_sort(two),
			n: [0,n_one, n_two]
		}
	};
	return info;


}


function midi2wav(midifile, sampleps){
	var sampleps = sampleps || 44100;
	// currently ignore setTempo
	var rep = new Replayer(midifile, 1, null);
	var data = rep.getData();
	var endTime = 500.0 * 2; // extra 500ms *2
	data.forEach(function(e){
		endTime += e[1];
	});


	var len = Math.floor(sampleps/1000 * endTime);
	console.log('length', len);
	var chL = new Float32Array(len), chR = new Float32Array(len);
	var curTime = 500.0; // in miliseconds
	var sources = {};
	function noteOn(channelId, noteId, velocity){
		var channel = MIDI.channels[channelId];
		var instrument = channel.program;
		if(channelId == 9){
			instrument = 128;
			velocity *= 0.75;
			//console.log('percussion');
		}
		var bufferId = instrument + 'x' + noteId;
		var buffer = MIDI.audioBuffers[bufferId];
		if(buffer == null){
			console.log('no buffer', bufferId);
			return;
		}
		// check if already noteOn;
		sources[channelId + 'x' + noteId] = {buffer:buffer, cur_i:0, vol:velocity/127, fade_out:-1};

	}
	function noteOff(channelId, noteId){
		var source = sources[channelId + 'x' + noteId];
		if(source){
			var fade_time = source.vol * 0.15; // should get from metadata
			source.fade_out = Math.floor(fade_time * sampleps);
		}

	}
	function forward(n){
		if(n<=0){
			return ;
		}

		var start_i = Math.floor(curTime * sampleps / 1000);
		//console.log('forward', n, start_i);

		for(var s in sources){
			var source = sources[s];
			var bL = source.buffer.getChannelData(0),
					bR = source.buffer.getChannelData(1),
					vol = source.vol;
			var i_to = start_i, i_from = source.cur_i;
			var real_n = n;
			if(i_from + real_n> bL.length){
				real_n = bL.length - i_from;
			}
			if(source.fade_out<0){
				// noteOn
				for(var i=0;i<real_n;++i, ++i_to, ++i_from){
					chL[i_to] += bL[i_from] * vol;
					chR[i_to] += bR[i_from] * vol;
				}
			}else{
				// noteOff, fade out
				var delta = vol/source.fade_out;
				if(source.fade_out<real_n){
					real_n = source.fade_out;
				}
				for(var i=0;i<real_n;++i, ++i_to, ++i_from){
					chL[i_to] += bL[i_from] * vol;
					chR[i_to] += bR[i_from] * vol;
					vol -= delta;
				}
				source.fade_out -= real_n;
				source.vol = vol;


			}
			source.cur_i = i_from;
			if(source.fade_out == 0 || source.cur_i >= bL.length){
				delete sources[s];
			}


		}


	}
	function processing(e){
		// TODO: add fade out
		forward(Math.floor(sampleps/1000 * e[1]));
		curTime += e[1];
		if(e[0].event.type !== 'channel'){
			return; //ignore non-channel event
		}
		var event = e[0].event;
		var channelId = event.channel;
		var channel = MIDI.channels[channelId];

		switch(event.subtype){
			case 'controller':
				MIDI.setController(channelId, event.controllerType, event.value, 0);// should check
				break;
			case 'programChange':
				MIDI.programChange(channelId, event.programNumber, 0);
				console.log('to mp3, programChange', event.programNumber);
				break;
			case 'pitchBend':
				MIDI.pitchBend(channelId, event.value, 0);
				break;
			case 'noteOn':
				if (channel.mute) break;
				noteOn(channelId, event.noteNumber, event.velocity);
				break;
			case 'noteOff':
				if (channel.mute) break;
				noteOff(channelId, event.noteNumber);
				break;
			default:
				break;
		}
	}

	// load all instruments
	MIDI.loadPlugin({
		instruments: MIDI.Player.getFileInstruments(data)
	}, function(){
		// after success
		console.log('loadededed');

	});
	data.forEach(processing);
	console.log('midi to mp3 processed');

	return [chL, chR];
}



    





;
//
// If absolute URL from the remote server is provided, configure the CORS
// header on that server.
//



//
// Disable workers to avoid yet another cross-origin issue (workers need
// the URL of the script to be loaded, and dynamically loading a cross-origin
// script does not work).
//
// PDFJS.disableWorker = true;

//
// In cases when the pdf.worker.js is located at the different folder than the
// pdf.js's one, or the pdf.js is executed via eval(), the workerSrc property
// shall be specified.
//
// PDFJS.workerSrc = '../../build/pdf.worker.js';




/**
 * Returns scale factor for the canvas. It makes sense for the HiDPI displays.
 * @return {Object} The object with horizontal (sx) and vertical (sy)
                    scales. The scaled property is set to false if scaling is
                    not required, true otherwise.
 */
function getOutputScale(ctx) {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                          ctx.mozBackingStorePixelRatio ||
                          ctx.msBackingStorePixelRatio ||
                          ctx.oBackingStorePixelRatio ||
                          ctx.backingStorePixelRatio || 1;
  var pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}

(function(self) {

  var pdfDoc = null,
      pageNum = 1,
      pageRendering = false,
      pageNumPending = null,
      scale = 5,
      wrapper = document.getElementById('canvas-wrapper'),
      the_canvas = document.getElementById('the-canvas'),
      ctx = the_canvas.getContext('2d');
  var pdf_canvas_buffers = [];
  the_canvas.style.width = "100%"; //(ratio * 100) + "%";

  /**
   * Get page info from document, resize canvas accordingly, and render page.
   * @param num Page number.
   */
  function renderPage(num) {
    // TODO: limit buffer size
    console.log('pdf render page', num);
    pageRendering = true;
    // Using promise to fetch the page
    pdfDoc.getPage(num).then(function (page) {
      var ratio = 8;
      var viewport = page.getViewport(scale);

      //console.log(viewport.width,viewport);
      var canvas = document.createElement('canvas');
      canvas.height = viewport.height;
      canvas.width = viewport.width;

      //canvas.style.transform = "scale(" + 1/ratio + ', ' + 1/ratio + ")" ;
      //canvas.style.transformOrigin = "0% 0%";
      //wrapper.style.width = Math.floor(viewport.width/ratio) + 'pt';
      //wrapper.style.height = Math.floor(viewport.height/ratio)+ 'pt';


      // Render PDF page into canvas context
      var renderContext = {
        canvasContext: canvas.getContext('2d'),
        viewport: viewport
      };
      var renderTask = page.render(renderContext);


      // Wait for rendering to finish
      renderTask.promise.then(function () {
        pageRendering = false;
        pdf_canvas_buffers[num - 1] = canvas;

        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pageNumPending);
          pageNumPending = null;
        }
      });


    });

  }

  /**
   * If another page rendering in progress, waits until the rendering is
   * finised. Otherwise, executes rendering immediately.
   */
  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPage(num);
    }
  }


  var pager = $('#pdf_pager');
  var UI = {
    prev: pager.find('.prev'),
    next: pager.find('.next'),
    page_num: pager.find('.page_num'),
    page_count: pager.find('.page_count')
  };

  /**
   * Displays previous page.
   */
  UI.prev.on('click', function () {
    if (pageNum <= 1) {
      return;
    }
    pageNum--;
    if (pdf_canvas_buffers[pageNum - 1] == null) {
      queueRenderPage(pageNum);
    }
    showPage(pageNum);
  });

  /**
   * Displays next page.
   */

  UI.next.on('click', function () {
    if (pageNum >= pdfDoc.numPages) {
      return;
    }
    pageNum++;
    if (pdf_canvas_buffers[pageNum - 1] == null) {
      queueRenderPage(pageNum);
    }
    showPage(pageNum); // should set Timeout
    if (pageNum + 1 < pdfDoc.numPages && pdf_canvas_buffers[pageNum] == null) {
      queueRenderPage(pageNum + 1); //pre rendering
    }
  });

  function showPage(num) {
    var canvas = pdf_canvas_buffers[num - 1];
    if (canvas == null) {
      console.log('null canvas');
      setTimeout(function () {
        showPage(num);
      }, 100);
      return false
    }
    the_canvas.width = canvas.width;
    the_canvas.height = canvas.height;
    ctx.drawImage(canvas, 0, 0);
    // Update page counters
    UI.page_num.html(pageNum);
    return true;
  }

  /**
   * Asynchronously downloads PDF.
   */
  function load_pdf(pdfurl) {
    PDFJS.getDocument(pdfurl).then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      pdf_canvas_buffers = [];
      pageNum = 1;
      UI.page_count.html(pdfDoc.numPages);
      // Initial/first page rendering
      renderPage(pageNum);
      showPage(pageNum);
      queueRenderPage(pageNum + 1);
    });
  }
  // export functionality
  self.load_pdf = load_pdf;

})(this);;
(function(self, wh, bh, bw, ww) {


    var oct = 5, offset = 0;
    var pitches = {};
    var keymap = (function(){
        var ret = {};
        'awsedfujikol;'.split('').forEach(function(e,i){
            ret[e] = i;
        });
        return ret;
    })();
    function keydown(evt){
        switch(evt.key){
            default:
                var pitch = keymap[evt.key];
                if(pitch == null) break;
                if(pitch - offset < 0) pitch += 12;
                if(pitch - offset > 12) pitch -= 12
                pitch += oct * 12;
                pitches[evt.key] = pitch;
                pressing(pitch);
        }
    };
    function keyup(evt){
        switch(evt.key){
            case 'q':
                if(oct * 12 + offset >= 33)
                    oct--;
                break;
            case 'p':
                if(oct * 12 + offset <= 84)
                  oct++;
                break;
            case 'g':
                if(oct * 12 + offset < 95)
                    offset += 2;
                if(offset > 6){
                    offset -= 12;
                    oct++;
                }
                break;
            case 'v':
                if(oct * 12 + offset < 96)
                    offset++;
                if(offset > 6){
                    offset -= 12;
                    oct++;
                }
                break;
            case 'h':
                if(oct * 12 + offset > 22)
                    offset -= 2;
                if(offset < -6){
                    offset += 12;
                    oct--;
                }
                break;
            case 'n':
                if(oct * 12 + offset > 21)
                    offset --;
                if(offset < -6){
                    offset += 12;
                    oct--;
                }
                break;
            default:
                var pitch = pitches[evt.key];
                if(pitch == null) break;
                release(pitch);
                delete pitches[evt.key];
        }
    }

    var pressed = {};
    function keyshape(type, pos_x) {

        switch (type) {
            case 1:
            case 4:
            case 6:
            case 9:
            case 11://blackkey
                return (pos_x - bw) + ',0 '
                    + (pos_x + bw) + ',0 '
                    + (pos_x + bw) + ',' + (bh) + ' '
                    + (pos_x - bw) + ',' + (bh);
            case 0:
            case 5:
            case 10://whitenormal
                return (pos_x - ww + bw) + ',0 '
                    + (pos_x + ww - bw) + ',0 '
                    + (pos_x + ww - bw) + ',' + (bh) + ' '
                    + (pos_x + ww) + ',' + (bh) + ' '
                    + (pos_x + ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (bh) + ' '
                    + (pos_x - ww + bw) + ',' + (bh);
                break;

            case 3:
            case 8:
            case -1://whiteleft
                return (pos_x - ww) + ',0 '
                    + (pos_x + ww - bw) + ',0 '
                    + (pos_x + ww - bw) + ',' + (bh) + ' '
                    + (pos_x + ww) + ',' + (bh) + ' '
                    + (pos_x + ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (wh);

            case 2:
            case 7://whiteright
                return (pos_x - ww + bw) + ',0 '
                    + (pos_x + ww) + ',0 '
                    + (pos_x + ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (bh) + ' '
                    + (pos_x - ww + bw) + ',' + (bh);
                break;
            case -2://whitewhole
                return (pos_x - ww) + ',0 '
                    + (pos_x + ww) + ',0 '
                    + (pos_x + ww) + ',' + (wh) + ' '
                    + (pos_x - ww) + ',' + (wh);
                break;
            default:
                return "";
                break;
        }
    }

    var keycolor = Array(12).fill(0).map(function (e, type) {
        switch (type) {
            case 1:
            case 3:
            case 6:
            case 8:
            case 10:
                return 'black';
            default:
                return 'white';
        }
    });


    function make_keyboard() {
        var temp = "";
        var pos_x = ww;
        for (var i = 0; i < 88; ++i) {
            if (i == 0)type = -1;
            else if (i == 87)
                type = -2;
            else
                type = i % 12;
            temp += '<polygon class="kb" data-piano-key-number="' + (21 + i) + '" points="' + keyshape(type, pos_x)
                + '" style="fill:' + keycolor[(i + 9) % 12] + ';stroke:gray;stroke-width:1;fill-rule:odd;"></polygon>>';
            pos_x += ww;
            if (type == 2 || type == 7) pos_x += ww;
        }
        return temp;
    }

    function make_modeboard(keys) {
        var res = '<input type="radio" name="musicMode" value="single" checked>Single note<br>\n';
        for (var i in keys) {
            var j = MG.chord_class_label[keys[i]];
            if (j != undefined) {
                res += '<input type="radio" name="musicMode" value="' + (keys[i]) + '">' + (j) + '<br>\n';
            }
        }
        return res;
    }


    var this_amplitude = 110;


    function pressing(pitch) {
        if(typeof pressed[pitch] != 'undefined'){
            return;
        }
        var mode = $(":radio[name=musicMode]:checked").val();
        pressed[pitch] = mode == "single" ? [0] : MG.chord_class[mode];
        this_amplitude = parseInt($("#amplitude").val());

        pressed[pitch].forEach(function (el) {
            if (pitch + el > 108) return;
            MIDI.noteOn(0, pitch + el, this_amplitude);
            var tgt = $('.kb[data-piano-key-number=' + (pitch + el) + ']');
            var color = "#444";
            if (keycolor[(pitch + el) % 12] == 'white') {
                color = "#DDD";
            }
            tgt.css("fill", color);
        });
    }

    function release(pitch) {
        if (typeof pressed[pitch] == 'undefined') return;
        // Show a simple message in the console
        // Send the note off message to match the pitch of the current note on event
        pressed[pitch].slice().forEach(function (el) {
            if (pitch + el > 108) return;
            MIDI.noteOff(0, pitch + el);
            $('.kb[data-piano-key-number=' + (pitch + el) + ']').css("fill", keycolor[(pitch + el) % 12]);

        });
        delete pressed[pitch];
    };

    self.handlePianoKeyRelease = function(evt){
        release(parseInt($(evt.target).data("piano-key-number")));
    };
    self.handlePianoKeyPress = function handlePianoKeyPress(evt) {
        var pitch = parseInt($(evt.target).data("piano-key-number"));
        pressing(pitch);
    };
    self.make_keyboard = make_keyboard;
    self.make_modeboard = make_modeboard;
    self.keyHandlers = [keydown, keyup];

})(this, 130, 70, 6, 9);

(function(self){
    var pressed = {};
    function pressing(kit){
        if(typeof pressed[kit] != 'undefined'){
            return;
        }
        var amplitude = parseInt($('#drum_amplitude').val());
        MIDI.noteOn(9, kit, amplitude);
        pressed[kit] = kit;
    }
    function release(kit){
        if(typeof pressed[kit] == 'undefined') return;

        delete pressed[kit];
    }
    var keymap = {
        'v': 36, 'f': 37, 'g': 38,
        'h': 50, 'b': 45, 'n': 41,
        'y': 49, 'i': 51, 'u': 46, 'j': 44, 'm': 42,
    };
    function keydown(evt){
        if(typeof keymap[evt.key] != 'undefined'){
            pressing(keymap[evt.key]);
        }else{
            // TODO: add other control change
            // switch
        }
    }
    function keyup(evt){
        if(typeof keymap[evt.key] != 'undefined'){
            release(keymap[evt.key]);
        }
    }
    self.drumHandlers = [keydown, keyup];
})(this)