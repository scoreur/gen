// Generated by CoffeeScript 1.10.0
(function() {
  var MG, alias, ex, ref1,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref1 = this.MG) != null ? ref1 : {};

  MG.instrs = {
    'Piano': ['1 Acoustic Grand Piano', '2 Bright Acoustic Piano', '3 Electric Grand Piano', '4 Honky-tonk Piano', '5 Electric Piano 1', '6 Electric Piano 2', '7 Harpsichord', '8 Clavinet'],
    'Chromatic Percussion': ['9 Celesta', '10 Glockenspiel', '11 Music Box', '12 Vibraphone', '13 Marimba', '14 Xylophone', '15 Tubular Bells', '16 Dulcimer'],
    'Organ': ['17 Drawbar Organ', '18 Percussive Organ', '19 Rock Organ', '20 Church Organ', '21 Reed Organ', '22 Accordion', '23 Harmonica', '24 Tango Accordion'],
    'Guitar': ['25 Acoustic Guitar (nylon)', '26 Acoustic Guitar (steel)', '27 Electric Guitar (jazz)', '28 Electric Guitar (clean)', '29 Electric Guitar (muted)', '30 Overdriven Guitar', '31 Distortion Guitar', '32 Guitar Harmonics'],
    'Bass': ['33 Acoustic Bass', '34 Electric Bass (finger)', '35 Electric Bass (pick)', '36 Fretless Bass', '37 Slap Bass 1', '38 Slap Bass 2', '39 Synth Bass 1', '40 Synth Bass 2'],
    'Strings': ['41 Violin', '42 Viola', '43 Cello', '44 Contrabass', '45 Tremolo Strings', '46 Pizzicato Strings', '47 Orchestral Harp', '48 Timpani'],
    'Ensemble': ['49 String Ensemble 1', '50 String Ensemble 2', '51 Synth Strings 1', '52 Synth Strings 2', '53 Choir Aahs', '54 Voice Oohs', '55 Synth Choir', '56 Orchestra Hit'],
    'Brass': ['57 Trumpet', '58 Trombone', '59 Tuba', '60 Muted Trumpet', '61 French Horn', '62 Brass Section', '63 Synth Brass 1', '64 Synth Brass 2'],
    'Reed': ['65 Soprano Sax', '66 Alto Sax', '67 Tenor Sax', '68 Baritone Sax', '69 Oboe', '70 English Horn', '71 Bassoon', '72 Clarinet'],
    'Pipe': ['73 Piccolo', '74 Flute', '75 Recorder', '76 Pan Flute', '77 Blown Bottle', '78 Shakuhachi', '79 Whistle', '80 Ocarina'],
    'Synth Lead': ['81 Lead 1 (square)', '82 Lead 2 (sawtooth)', '83 Lead 3 (calliope)', '84 Lead 4 (chiff)', '85 Lead 5 (charang)', '86 Lead 6 (voice)', '87 Lead 7 (fifths)', '88 Lead 8 (bass + lead)'],
    'Synth Pad': ['89 Pad 1 (new age)', '90 Pad 2 (warm)', '91 Pad 3 (polysynth)', '92 Pad 4 (choir)', '93 Pad 5 (bowed)', '94 Pad 6 (metallic)', '95 Pad 7 (halo)', '96 Pad 8 (sweep)'],
    'Synth Effects': ['97 FX 1 (rain)', '98 FX 2 (soundtrack)', '99 FX 3 (crystal)', '100 FX 4 (atmosphere)', '101 FX 5 (brightness)', '102 FX 6 (goblins)', '103 FX 7 (echoes)', '104 FX 8 (sci-fi)'],
    'Ethnic': ['105 Sitar', '106 Banjo', '107 Shamisen', '108 Koto', '109 Kalimba', '110 Bagpipe', '111 Fiddle', '112 Shanai'],
    'Percussive': ['113 Tinkle Bell', '114 Agogo', '115 Steel Drums', '116 Woodblock', '117 Taiko Drum', '118 Melodic Tom', '119 Synth Drum'],
    'Sound effects': ['120 Reverse Cymbal', '121 Guitar Fret Noise', '122 Breath Noise', '123 Seashore', '124 Bird Tweet', '125 Telephone Ring', '126 Helicopter', '127 Applause', '128 Gunshot']
  };

  this.chord_num = MG.chord_class = {
    "maj": [0, 4, 7],
    "min": [0, 3, 7],
    "dim": [0, 3, 6],
    "aug": [0, 4, 8],
    "dom7": [0, 4, 7, 10],
    "maj7": [0, 4, 7, 11],
    "min7": [0, 3, 7, 10],
    "aug7": [0, 4, 8, 10],
    "dim7": [0, 3, 6, 9]
  };

  MG.inverted = function(arr, n) {
    var i, m, ref2, ret;
    if (n == null) {
      n = 1;
    }
    n = modulo(n, arr.length);
    ret = new Array(arr.length);
    for (i = m = 0, ref2 = arr.length; m < ref2; i = m += 1) {
      ret[i] = modulo(arr[(n + i) % arr.length] - arr[n], 12);
    }
    return ret;
  };

  MG.chords = (function() {
    var c, ci, i, m, ref2, ref3, res, v;
    res = {};
    ref2 = MG.chord_class;
    for (c in ref2) {
      v = ref2[c];
      ci = c + '';
      for (i = m = 0, ref3 = v.length; m < ref3; i = m += 1) {
        res[ci] = MG.inverted(v, i);
        ci += 'i';
      }
    }
    return res;
  })();

  MG.interval_class = {
    'u1': 0,
    'm2': 1,
    'M2': 2,
    'm3': 3,
    'M3': 4,
    'p4': 5,
    'a4': 6,
    'd5': 6,
    'p5': 7,
    'm6': 8,
    'M6': 9,
    'm7': 10,
    'M7': 11,
    'o8': 12
  };

  MG.key_class = (function() {
    var kn1, kn2, res;
    kn1 = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    kn2 = ['B#', 'C#', 'D', 'D#', 'Fb', 'E#', 'F#', 'G', 'G#', 'A', 'A#', 'Cb'];
    res = {};
    kn1.forEach(function(e, i) {
      res[e] = i;
    });
    kn2.forEach(function(e, i) {
      res[e] = i;
    });
    return res;
  })();

  MG.scale_class = {
    'maj': [0, 2, 4, 5, 7, 9, 11],
    'min': [0, 2, 3, 5, 7, 8, 10],
    'min_harmonic': [0, 2, 3, 5, 7, 8, 11],
    'min_melodic': [0, 2, 3, 5, 7, 9, 11],
    'chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    'octatonic': [0, 1, 3, 4, 6, 7, 9, 10],
    'whole': [0, 2, 4, 6, 8, 10],
    'dorian': [0, 2, 3, 5, 7, 9, 10],
    'lydian': [0, 2, 4, 6, 7, 9, 11],
    'pent': [0, 2, 4, 7, 9],
    'pent_min': [0, 3, 5, 7, 10],
    'zhi': [0, 2, 5, 7, 9],
    'blues': [0, 3, 5, 6, 7, 10]
  };

  this.white_key_num = [0, 2, 4, 5, 7, 9, 11];

  this.black_key_num = [1, 3, 6, 8, 10];

  MG.scaleToPitch = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(num) {
      return ref + (Math.floor(num / scale.length)) * 12 + scale[modulo(num, scale.length)] + 12;
    };
  };

  MG.pitchToScale = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(pitch) {
      var i, m, oct, ref4;
      pitch -= ref;
      oct = Math.floor(pitch / 12) - 1;
      pitch = modulo(pitch, 12);
      for (i = m = ref4 = scale.length - 1; m >= 0; i = m += -1) {
        if (pitch >= scale[i]) {
          return [i, oct, pitch - scale[i]];
        }
      }
      return [0, oct, pitch - scale[0]];
    };
  };

  MG.testPitchScaleConversion = function() {
    var flag, i, j, m, mode, ref2, scale, tmp, toPitch, toScale, tonic;
    ref2 = MG.scale_class;
    for (scale in ref2) {
      mode = ref2[scale];
      flag = true;
      for (tonic in MG.key_class) {
        toPitch = MG.scaleToPitch(scale, tonic);
        toScale = MG.pitchToScale(scale, tonic);
        for (i = m = 21; m <= 108; i = ++m) {
          tmp = toScale(i);
          j = toPitch(tmp[0] + mode.length * tmp[1]) + tmp[2];
          if (j !== i) {
            flag = false;
            console.log(tonic, scale, i, tmp, j);
          }
        }
      }
      if (flag) {
        console.log(scale, 'success');
      }
    }
  };

  MG.keyToPitch = function(key) {
    var key_class, oct, ref, ref2, ref3;
    key_class = /[CDEFGAB][#b]{0,2}/.exec(key)[0];
    if (key_class == null) {
      key_class = 'C';
    }
    ref = (ref2 = MG.key_class[key_class]) != null ? ref2 : 0;
    oct = /[0-9]/.exec(key)[0];
    oct = (ref3 = parseInt(oct)) != null ? ref3 : 4;
    return 12 + ref + oct * 12;
  };

  MG.pitchToKey = function(pitch, sharp, nooct) {
    var kn, ref;
    if (pitch < 21 || pitch > 108) {
      return void 0;
    }
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    if (sharp === true) {
      kn = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    }
    ref = pitch % 12;
    if (nooct != null) {
      return kn[ref];
    } else {
      return [kn[ref], Math.floor(pitch / 12) - 1];
    }
  };

  MG.testPitchKeyConversion = function() {
    var flag, i, j, m, tmp;
    flag = true;
    for (i = m = 21; m <= 108; i = ++m) {
      tmp = MG.pitchToKey(i, true);
      j = MG.keyToPitch(tmp[0] + tmp[1]);
      if (j !== i) {
        flag = false;
        console.log(i, tmp, j);
      }
    }
    if (flag) {
      console.log('success');
    }
  };

  MG.transposer = function(scale_name, key_sig) {
    var scale_len, toPitch, toScale;
    if (scale_name == null) {
      scale_name = 'chromatic';
    }
    console.log(scale_name, 'transposer');
    if (key_sig == null) {
      key_sig = 'C';
    }
    scale_len = MG.scale_class[scale_name].length;
    toScale = MG.pitchToScale(scale_name, key_sig);
    toPitch = MG.scaleToPitch(scale_name, key_sig);
    return function(pitch, diff) {
      var tmp;
      tmp = toScale(pitch);
      return toPitch(tmp[0] + tmp[1] * scale_len + diff) + tmp[2];
    };
  };

  ex = /[ABCDEFG][b#]{0,2}/;

  alias = {
    '7': 'dom7',
    '': 'maj',
    'M': 'maj',
    'm': 'min',
    'mi': 'min',
    'm7': 'min7'
  };

  MG.getChords = function(chord_str, oct) {
    var chord_name, chord_pitches, ref2, root, root_pitch;
    if (oct == null) {
      oct = 4;
    }
    root = ex.exec(chord_str)[0];
    root_pitch = MG.keyToPitch(root + oct);
    chord_name = chord_str.substr(ex.lastIndex + root.length);
    chord_name = (ref2 = alias[chord_name]) != null ? ref2 : chord_name;
    chord_pitches = MG.chords[chord_name] || MG.chords['maj'];
    return [root_pitch, chord_pitches];
  };

  MG.key_sig_rev = {};

  MG.key_sig = (function() {
    var i, j, kn, l, m, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    for (i = m = 0; m < 12; i = m += 1) {
      j = (i * 7) % 12;
      l = (i + 6) % 12 - 6;
      res[kn[j]] = l;
      MG.key_sig_rev[l] = kn[j];
    }
    res['F#'] = 6;
    MG.key_sig_rev[6] = 'F#';
    return res;
  })();

  MG.keyNames = (function() {
    var ref, res;
    res = new Array(12).fill(0).map(function(e) {
      return [];
    });
    ref = MG.scale_class['maj'];
    "CDEFGAB".split("").forEach(function(key, i) {
      res[modulo(ref[i] - 2, 12)].push(key + 'bb');
      res[modulo(ref[i] - 1, 12)].push(key + 'b');
      res[ref[i] % 12].push(key);
      res[(ref[i] + 1) % 12].push(key + '#');
      return res[(ref[i] + 2) % 12].push(key + '##');
    });
    return res;
  })();

  MG.scale_keys = (function() {
    var kn, ref, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    res['C'] = "CDEFGAB".split("");
    ref = MG.scale_class['maj'];
    kn.forEach(function(e, i) {
      var j, k, m, notes, pitch, ref2, results, v;
      if (e === 'C') {
        return;
      }
      res[e] = [e];
      results = [];
      for (j = m = 1, ref2 = ref.length; m < ref2; j = m += 1) {
        pitch = (i + ref[j]) % 12;
        notes = MG.keyNames[pitch];
        results.push((function() {
          var results1;
          results1 = [];
          for (k in notes) {
            v = notes[k];
            if (v[0] === res['C'][(res['C'].indexOf(e[0]) + j) % 7]) {
              res[e].push(v);
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    });
    return res;
  })();

  this.chord_name = MG.chord_class_label = {
    "maj": "Major triad",
    "min": "Minor triad",
    "aug": "Augmented triad",
    "dim": "Diminished triad",
    "dom7": "Dominant seventh chord",
    "maj7": "Major seventh chord",
    "min7": "Minor seventh chord",
    "aug7": "Augmented seventh chord",
    "dim7": "Diminished seventh chord"
  };

  this.score_summer = MG.score_summer = {
    settings: {
      tempo: 120,
      time_sig: [4, 4],
      key_sig: 'C',
      scale: 'maj',
      ctrl_per_beat: 2,
      incomplete_measure: true,
      volumes: [110, 80],
      instrs: [1, 1]
    },
    contents: {
      melody: ':+ 3,2 1,2/3,8^/3,2 2 1 2 3 1,2/:- 6,4 3,4^/3,4 :+ 3,2 1,2/2 2,7^/2,2 1 6-,1 1 6-,1 1,2/:- 7,8^/7,4 0 :+ 3,2 1/3 3,2 3,1^ 3,4^/3,2 2 1 2 3 1,2/:- 6,4 3,4^/3,6 3,2/5,2 3 5 6,2 :+ 1,2/3 2,3 1,4/:- 6,8^/6,4 :+ 3,2 1,2'.split('/'),
      harmony: "E7,4/Amin,8/Bb7,8/Amin,4 E7,4/Amin,4 A7,4/Dmin,8/F7,8/F#min7,4 B7,4/E7,8/Am,8/Bb7,8/Am,8/D7,8/C,4 Am,4/D7,4 E7,4/Am,4 D7,4/Bm7,4 E7,4".split('/'),
      texture: "@-123 123,4/@-11-32+ 12,2 3,2 4,2 3,2/@iii-11-32+ 12,2 3,2 4,2 3,2/@-123 123,4 @-123 123,4/@-123 123,4 @-123 123,4/@-11-32+ 12,2 3,2 4,2 3,2/@-11-32+ 12,2 3,2 4,2 3,2/@-123 123,4 123,4/@-11-32+ 12,2 3,2 4,2 3,2/@-123 123,4 123,4/@-123 123,4 123,4/@-123 123,4 123,4/@-123 123,4 123,4/@-123 123,4 @-123 123,4/@-123 123,4 @-123 123,4/@-123 123,4 @-123 123,4/@-123 123,4 @-123 123,4".split('/')
    }
  };

  this.gen_modes = ['random', 'transpose', 'chord', 'reverse', 'sequence'];

  this.schema_summer = MG.schema_summer = {
    blocks: (function(a, b) {
      var res;
      res = {};
      a.split('/').forEach(function(e, i) {
        return res[e] = b[i];
      });
      return res;
    })('c/A/B/Br/C', [4, 32, 16, 16, 28]),
    structure: "c/A/B/Br/A/C/c".split('/'),
    scale: 'maj',
    funcs: {
      'A': "1,8/4,8/1,4 2,4/1,8".split('/'),
      'B': "4,8/6,8".split('/'),
      'Br': "2,4 5,4/5,8".split('/'),
      'C': "3,4 1,4/2,4 5,4/1,4 2,4/2,4".split('/'),
      'c': "5,4"
    },
    seeds: {
      's1': {
        dur: 4,
        choices: '1 1 1 1/2 1 1/1 1 2/1 2 1/1 3/3 1/2 2/4'.split('/').map(function(e) {
          return e.split(/\s+/).map(function(e2) {
            return parseInt(e2);
          });
        }),
        weights: [2, 3, 3, 5, 1, 3, 2, 1]
      },
      's2': {
        weights: [1, 1, 2, 5, 12, 6, 8, 4, 7, 12, 8, 3, 1, 0, 1],
        choices: (function() {
          return Array(15).fill().map(function(e, i) {
            return i - 7;
          });
        })()
      }
    },
    melody: {
      'c': {
        mode: 'random',
        options: {
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      },
      'A': {
        mode: 'random',
        options: {
          chords: ["Amin,8", "Bb7,8", "Amin,4 E7,4", "Amin,4 A7,4"],
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      },
      'B': {
        mode: 'transpose',
        options: {
          src: "A",
          offset: 0,
          scale: 'maj',
          interval: 4
        }
      },
      'Br': {
        mode: 'reverse',
        options: {
          src: 'B',
          deep: 'false'
        }
      },
      'C': {
        mode: 'chord',
        options: {
          chords: "C,4 Am,4/D7,4 E7,4/Am,4 D7,4/Bm7,4".split('/'),
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      }
    }
  };

  this.MG = MG;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MG;
  }

}).call(this);

//# sourceMappingURL=musical.js.map
;/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,17],$V1=[1,18],$V2=[1,15],$V3=[1,16],$V4=[1,13],$V5=[1,4,10,11,19,20,39],$V6=[1,23],$V7=[1,24],$V8=[1,25],$V9=[4,13,14,15],$Va=[1,35],$Vb=[1,36],$Vc=[1,37],$Vd=[1,38],$Ve=[1,39],$Vf=[4,10,11,13,14,15,43],$Vg=[4,13,14,15,22,24,26,28,33,34,35,36,37],$Vh=[10,11,33,34,35,36,37,41],$Vi=[4,10,11,13,14,15,33,34,35,36,37,43],$Vj=[4,10,11,13,14,15,22,23,24,26,28,33,34,35,36,37,43,44],$Vk=[4,10,11,13,14,15,22,24,26,28,33,34,35,36,37,41,43];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"e":3,"EOF":4,"M":5,"Measure":6,"melody":7,"harmony":8,"NUMBER":9,"DIGIT":10,"DIGITS":11,"M_end":12,"M_SEP":13,"BAR":14,"REPEAT_END":15,"Note":16,"Ctrl":17,"C0":18,"CTRL_START":19,"REPEAT_START":20,"C1":21,"t":22,"/":23,"k":24,"KEY":25,"Op_string":26,"STRING":27,"Op_unary":28,"P1":29,"C":30,"Chord":31,"P":32,"#":33,"FLAT":34,"+":35,"-":36,"NATURAL":37,"Pitches":38,"CHORD_START":39,"Inverse":40,"i":41,"DUR":42,",":43,"^":44,"$accept":0,"$end":1},
terminals_: {2:"error",4:"EOF",7:"melody",8:"harmony",10:"DIGIT",11:"DIGITS",13:"M_SEP",14:"BAR",15:"REPEAT_END",19:"CTRL_START",20:"REPEAT_START",22:"t",23:"/",24:"k",25:"KEY",26:"Op_string",27:"STRING",28:"Op_unary",33:"#",34:"FLAT",35:"+",36:"-",37:"NATURAL",39:"CHORD_START",41:"i",43:",",44:"^"},
productions_: [0,[3,2],[3,3],[3,2],[3,1],[3,1],[3,1],[9,1],[9,1],[6,2],[6,3],[12,1],[12,1],[5,1],[5,1],[5,3],[5,3],[18,1],[18,1],[21,4],[21,2],[21,2],[21,2],[21,1],[30,1],[30,2],[17,1],[17,1],[32,1],[32,2],[29,1],[29,1],[29,1],[29,1],[29,1],[38,1],[38,2],[31,3],[40,2],[40,2],[40,0],[16,2],[42,2],[42,3],[42,0]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

    this.$ = $$[$0-1];
    return this.$;
  
break;
case 2:

    $$[$0-1].push({
      ctrl: 'normal_end'
    });
    $$[$0-2].data.push($$[$0-1]);
    this.$ = $$[$0-2];
    return this.$;
  
break;
case 3:

    /* push new measure */
    $$[$0-1].data.push($$[$0])
    this.$ = $$[$0-1]
  
break;
case 4:

    /* default as melody */
    this.$ = {
      mode:'melody',
      data: [$$[$0]]
      };
  
break;
case 5:

    /* create new track*/
    this.$ = {mode:'melody'};
  
break;
case 6:

    this.$ = {mode:'harmony'};
  
break;
case 7:

    this.$ = parseInt($$[$0]);
  
break;
case 8:
 /* remove brackets */
    this.$ = parseInt($$[$0].substr(1,$$[$0].length-2));
    console.log('braket number', this.$);
  
break;
case 9: case 36:

    $$[$0-1].push($$[$0]);
    this.$ = $$[$0-1];
  
break;
case 10: case 15: case 16:

    $$[$0-2].push($$[$0]);
    this.$ = $$[$0-2];
  
break;
case 11:

    this.$ = {
      ctrl: 'normal_end'
    };
  
break;
case 12:

    this.$ = {
      ctrl: 'repeat_end'
    };
  
break;
case 13: case 14: case 35:

    this.$ = [$$[$0]];
  
break;
case 17:

    this.$ = ['ctrl', 'reset'];
  
break;
case 18:

    this.$ = ['ctrl', 'repeat_start'];
  
break;
case 19:

    this.$ = [$$[$0-3], [$$[$0-2], $$[$0]]];
  
break;
case 20:

    this.$ = [$$[$0-1], $$[$0]];
  
break;
case 21:

    this.$ = [$$[$0-1], $$[$0].substr(1, $$[$0].length-2)];
  
break;
case 22:

    this.$ = [$$[$0-1][0], $$[$0]];
  
break;
case 23:

    this.$ = ['p', $$[$0]];
  
break;
case 24:

    this.$ = {};
    this.$[$$[$0][0]] = $$[$0][1];
  
break;
case 25:

    $$[$0-1][$$[$0][0]] = $$[$0][1];
    if($$[$0-1].ctrl == 'reset'){
      $$[$0-1].ctrl = 'normal';
    }
    this.$ = $$[$0-1];
  
break;
case 26: case 27: case 28:

    this.$ = $$[$0];
  
break;
case 29:

    if(typeof $$[$0-1] == 'number'){
      $$[$0-1] = {
        original: $$[$0-1],
        ornament: [$$[$0]]
      };
    }else{
      $$[$0-1].ornament.push($$[$0]);
    }
    this.$ = $$[$0-1]
  
break;
case 30:

    this.$ = 1;
  
break;
case 31:

    this.$ = -1;
  
break;
case 32:

    this.$ = 12;
  
break;
case 33:

    this.$ = -12;
  
break;
case 34:

    this.$ = 0;
  
break;
case 37:

    this.$ = {};
    this.$.ctrl = 'chord';
    this.$.transpose = $$[$0-1].transpose;
    this.$.inv = $$[$0-1].inv;
    this.$.pitch = $$[$0];
  
break;
case 38:

    $$[$0-1].inv += 1;
    this.$ = $$[$0-1];
  
break;
case 39:

    $$[$0-1].transpose += $$[$0];
    this.$ = $$[$0-1];
  
break;
case 40:

    this.$ = {inv: 0, transpose: 0};
  
break;
case 41:

    this.$ = {
      pitch:$$[$0-1],
      dur: $$[$0]
      };
  
break;
case 42:

    this.$ = $$[$0];

  
break;
case 43:

    this.$ = {
      original: $$[$0-1],
      ornament: 'tie'
    	}
  
break;
case 44:
 this.$ = 1
break;
}
},
table: [{3:1,5:5,6:2,7:[1,3],8:[1,4],9:14,10:$V0,11:$V1,16:6,17:7,18:12,19:$V2,20:$V3,30:9,31:10,32:11,38:8,39:$V4},{1:[3],4:[1,19],5:20,6:21,9:14,10:$V0,11:$V1,16:6,17:7,18:12,19:$V2,20:$V3,30:9,31:10,32:11,38:8,39:$V4},o($V5,[2,4]),o($V5,[2,5]),o($V5,[2,6]),{12:22,13:$V6,14:$V7,15:$V8},o($V9,[2,13]),o($V9,[2,14]),o($V9,[2,44],{9:14,42:26,32:27,10:$V0,11:$V1,43:[1,28]}),o($V9,[2,26],{21:29,29:34,22:[1,30],24:[1,31],26:[1,32],28:[1,33],33:$Va,34:$Vb,35:$Vc,36:$Vd,37:$Ve}),o($V9,[2,27]),o($Vf,[2,35],{29:40,33:$Va,34:$Vb,35:$Vc,36:$Vd,37:$Ve}),o($Vg,[2,24]),o($Vh,[2,40],{40:41}),o($Vi,[2,28]),o($Vg,[2,17]),o($Vg,[2,18]),o($Vj,[2,7]),o($Vj,[2,8]),o($V5,[2,1]),{4:[1,42],12:22,13:$V6,14:$V7,15:$V8},o($V5,[2,3]),o($V5,[2,9]),{9:14,10:$V0,11:$V1,12:43,14:$V7,15:$V8,16:44,17:45,18:12,19:$V2,20:$V3,30:9,31:10,32:11,38:8,39:$V4},o($V5,[2,11]),o($V5,[2,12]),o($V9,[2,41]),o($Vf,[2,36],{29:40,33:$Va,34:$Vb,35:$Vc,36:$Vd,37:$Ve}),{9:46,10:$V0,11:$V1},o($Vg,[2,25]),{9:47,10:$V0,11:$V1},{25:[1,48]},{27:[1,49]},{9:50,10:$V0,11:$V1},o($Vg,[2,23]),o($Vk,[2,30]),o($Vk,[2,31]),o($Vk,[2,32]),o($Vk,[2,33]),o($Vk,[2,34]),o($Vi,[2,29]),{9:14,10:$V0,11:$V1,29:53,32:11,33:$Va,34:$Vb,35:$Vc,36:$Vd,37:$Ve,38:51,41:[1,52]},o($V5,[2,2]),o($V5,[2,10]),o($V9,[2,15]),o($V9,[2,16]),o($V9,[2,42],{44:[1,54]}),{23:[1,55]},o($Vg,[2,20]),o($Vg,[2,21]),o($Vg,[2,22]),o($V9,[2,37],{9:14,32:27,10:$V0,11:$V1}),o($Vh,[2,38]),o($Vh,[2,39]),o($V9,[2,43]),{9:56,10:$V0,11:$V1},o($Vg,[2,19])],
defaultActions: {},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

	
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return yy_.yytext;
break;
case 1:this.begin('NOTE'); return 10;
break;
case 2:this.begin('INITIAL'); return 14;
break;
case 3:this.begin('CTRL'); return 20;
break;
case 4:this.begin('INITIAL'); return 14;
break;
case 5:this.begin('INITIAL'); return 15;
break;
case 6:this.begin('CTRL'); return 19;
break;
case 7:this.begin('CHORD'); return 39;
break;
case 8:return 25;
break;
case 9:this.begin('NOTE'); return 13;
break;
case 10:/* skip */
break;
case 11:/* skip */
break;
case 12:return yy_.yytext[0];
break;
case 13:return 28;
break;
case 14:return 26;
break;
case 15:return 10;
break;
case 16:return 27;
break;
case 17:return 41;
break;
case 18:return 10;
break;
case 19:return 11;
break;
case 20:this.begin('NOTE_DUR'); return 43;
break;
case 21:return 37;
break;
case 22:return 34;
break;
case 23:return yy_.yytext;
break;
case 24:return 4;
break;
case 25:console.log('Unrecognized token: ', yy_.yytext);
break;
}
},
rules: [/^(?:((melody|harmony)))/,/^(?:(([0-9]))+)/,/^(?:((\r|\n|\r\n)))/,/^(?:\|:)/,/^(?:\|)/,/^(?::\|)/,/^(?::)/,/^(?:@)/,/^(?:(([A-GR][#b]{0,2})))/,/^(?:(([ |\t|\f|\v]))+)/,/^(?:\s+)/,/^(?:((%[^\r\n]*((\r|\n|\r\n)))))/,/^(?:((key_sig|time_sig|instrument|[k|t|i])))/,/^(?:((rate|volume|ctrls|[r|c|v])))/,/^(?:((out|scale|[o|s])))/,/^(?:(([0-9]))+)/,/^(?:\{[a-z_]+\})/,/^(?:[i])/,/^(?:(([0-9])))/,/^(?:\{(([0-9]))+\})/,/^(?:,)/,/^(?:[n])/,/^(?:[b])/,/^(?:((,|;|\{|\}|\+|-|#|\/|\^)))/,/^(?:$)/,/^(?:.)/],
conditions: {"CTRL":{"rules":[2,3,4,5,6,7,8,9,12,13,14,15,16,23,24,25],"inclusive":true},"NOTE":{"rules":[2,3,4,5,6,7,8,9,18,19,20,21,22,23,24,25],"inclusive":true},"NOTE_DUR":{"rules":[2,3,4,5,6,7,8,9,15,23,24,25],"inclusive":true},"CHORD":{"rules":[3,4,5,6,7,8,9,17,18,23,24,25],"inclusive":true},"INITIAL":{"rules":[0,1,3,4,5,6,7,8,10,11,23,24,25],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
};// Generated by CoffeeScript 1.10.0
(function() {
  var Analyzer, MG, ref;

  MG = (ref = this.MG) != null ? ref : {};

  Analyzer = (function() {
    function Analyzer(key_sig, scale_name) {
      this.key_sig = key_sig;
      this.scale_name = scale_name;
      this.scale = MG.scale_class[this.scale_name];
      this.key_ref = MG.key_class[this.key_sig];
      this.toScale = MG.pitchToScale(this.scale_name, this.key_sig);
      this.key_sig_acc = MG.key_sig[this.key_sig];
    }

    Analyzer.prototype.pitch_info = function(pitch, chord) {
      var i, info, key, p, ref1, sharp, tmp;
      info = {};
      if (chord != null) {
        if (typeof chord === 'string') {
          chord = MG.getChords(chord, 3);
        }
        info.isChordTone = false;
        ref1 = chord[1];
        for (i in ref1) {
          p = ref1[i];
          if ((chord[0] + p - pitch) % 12 === 0) {
            info.isChordTone = true;
            break;
          }
        }
      }
      tmp = this.toScale(pitch);
      info.inScale = tmp[2] === 0;
      key = MG.scale_keys[s.key_sig][tmp[0]];
      sharp = MG.key_sig[this.key_sig] >= 0;
      info.keyName = info.inScale ? [
        key, Math.floor(pitch / 12) - ({
          'Cb': 0,
          'B#': 2
        }[key] || 1)
      ] : MG.pitchToKey(pitch, sharp);
      return info;
    };

    return Analyzer;

  })();

  MG.Analyzer = Analyzer;

}).call(this);

//# sourceMappingURL=Analyzer.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG;

  MG = ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null) && require('./musical')) || this.MG;

  this.AppMG = (function() {
    function AppMG(ui, options) {
      if (options != null) {
        this.schema = options.schema, this.settings = options.settings, this.contents = options.contents;
      } else {
        this.schema = Object.assign({}, MG.schema_summer);
        this.settings = Object.assign({}, MG.score_summer.settings);
        this.contents = Object.assign({}, MG.score_summer.contents);
      }
      if (ui != null) {
        this.editor = ui.editor, this.renderer = ui.renderer, this.player = ui.player, this.playbtns = ui.playbtns;
      }
      return;
    }

    AppMG.prototype["export"] = function() {
      return {
        settings: this.settings,
        schema: this.schema,
        contents: this.contents
      };
    };

    AppMG.prototype.updateEditor = function() {
      ['melody', 'harmony', 'texture'].forEach((function(_this) {
        return function(e) {
          _this.editor[e].setValue(_this.contents[e].join('\n'), -1);
        };
      })(this));
      this.editor.score.setValue(JSON.stringify(this.settings, null, 2), -1);
      this.editor.schema.setValue(JSON.stringify(this.schema, null, 2), -1);
    };

    AppMG.prototype.play = function(n) {
      if (!this.player.playing[n]) {
        this.player.play(n);
      } else {
        this.player.pause(n);
      }
      return this.playbtns[n].toggleClass('glyphicon-play glyphicon-pause');
    };

    AppMG.prototype.parse = function() {
      var e, error;
      try {
        this.settings = JSON.parse(this.editor.score.getValue());
      } catch (error) {
        e = error;
        $.notify('Bad score format!', 'warning');
      }
      ['melody', 'harmony', 'texture'].forEach((function(_this) {
        return function(e) {
          return _this.contents[e] = _this.editor[e].getValue().split(/[\/\n]+/);
        };
      })(this));
      return this.player.fromScore(this.settings, this.contents);
    };

    return AppMG;

  })();

}).call(this);

//# sourceMappingURL=appMG.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, ref,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref = this.MG) != null ? ref : {};

  this.Generator = (function() {
    function Generator(settings, schema) {
      var base, base1, base2;
      this.settings = settings;
      this.schema = schema;
      if ((base = this.settings).key_sig == null) {
        base.key_sig = 'C';
      }
      if ((base1 = this.settings).scale == null) {
        base1.scale = 'maj';
      }
      if ((base2 = this.settings).instrs == null) {
        base2.instrs = [1, 1];
      }
      this.keyref = MG.keyToPitch[this.settings.key_sig + '4'];
      this.scale = MG.scale_class[this.settings.scale];
      this.seeds = this.schema.seeds;
      this.res = {};
      this.toPitch = MG.scaleToPitch(this.settings.scale, this.settings.key_sig);
      this.toScale = MG.pitchToScale(this.settings.scale, this.settings.key_sig);
    }

    Generator.prototype.generate = function() {
      var dur, i, mode, ref1;
      ref1 = this.schema.blocks;
      for (i in ref1) {
        dur = ref1[i];
        mode = this.schema.melody[i];
        switch (mode.mode) {
          case 'random':
            this.res[i] = this.gen_random(dur, mode.options);
            break;
          case 'transpose':
            this.res[i] = this.gen_transpose(dur, mode.options);
            break;
          case 'chord':
            this.res[i] = this.gen_chord(dur, mode.options);
            break;
          case 'reverse':
            this.res[i] = this.gen_reverse(mode.options);
        }
      }
      console.log(this.res, 'res');
      return this.res;
    };

    Generator.prototype.gen_transpose = function(dur, options) {
      var cur_i, interval, refd, res, src, tmp, tmp2, transpose;
      res = {
        dur: [],
        pitch: []
      };
      transpose = MG.transposer(options.scale, this.settings.key_sig);
      src = this.res[options.src];
      interval = options.interval;
      if (typeof interval === 'number') {
        interval = [interval];
      }
      refd = 0;
      cur_i = 0;
      while (dur > 0) {
        console.log(refd, src.dur.length);
        if (refd >= src.dur.length) {
          refd -= src.dur.length;
          cur_i = (cur_i + 1) % interval.length;
          console.log('shift to next interval');
        }
        tmp = [];
        tmp2 = [];
        src.dur[refd].forEach(function(e, i) {
          if (dur - e >= 0) {
            tmp.push(e);
            tmp2.push(transpose(src.pitch[refd][i], interval[cur_i]));
            dur -= e;
          } else if (dur > 0) {
            tmp.push(dur);
            tmp2.push(transpose(src.pitch[refd][i], interval[cur_i]));
            dur = 0;
          }
        });
        refd++;
        res.dur.push(tmp);
        res.pitch.push(tmp2);
      }
      return res;
    };

    Generator.prototype.gen_reverse = function(options) {
      var res, src;
      res = {
        dur: [],
        pitch: []
      };
      src = this.res[options.src];
      if ((options.deep != null) && options.deep === true) {
        res.dur = src.dur.slice().reverse().map(function(arr) {
          return arr.slice().reverse();
        });
        res.pitch = src.pitch.slice().reverse().map(function(arr) {
          return arr.slice().reverse();
        });
      } else {
        res.dur = src.dur.slice().reverse();
        res.pitch = src.pitch.slice().reverse();
      }
      console.log(res, 'reverse ' + options.src);
      return res;
    };

    Generator.prototype.gen_exact = function(options) {
      var res;
      return res = {
        dur: options.dur,
        pitch: options.pitch
      };
    };

    Generator.prototype.gen_random = function(dur, options) {
      var i, j, n, pre, rc1, rc2, res, scale_len, seed, seed2, tmp, toPitch;
      toPitch = this.toPitch;
      scale_len = this.scale.length;
      res = {
        dur: [],
        pitch: []
      };
      seed = {};
      if ((options.rhythm.seed != null) && (this.seeds != null)) {
        seed = this.seeds[options.rhythm.seed];
      } else {
        seed.dur = options.rhythm[0];
        seed.choices = options.rhythm[1];
        seed.weights = options.rhythm[2];
      }
      seed2 = {};
      if ((options.interval.seed != null) && (this.seeds != null)) {
        seed2 = this.seeds[options.interval.seed];
      } else {
        seed2 = options.interval;
      }
      n = dur / seed.dur >>> 0;
      rc1 = this.rndPicker(seed.choices, seed.weights);
      console.log(seed);
      rc2 = this.rndPicker(seed2.choices, seed2.weights);
      pre = scale_len * 4;
      i = 0;
      while (i < n) {
        res.dur.push(rc1.gen());
        tmp = [];
        j = 0;
        while (j < res.dur[i].length) {
          pre += rc2.gen() % scale_len;
          if (pre < 0) {
            pre = 0;
          }
          if (pre > scale_len * 8) {
            pre = scale_len * 8;
          }
          tmp.push(toPitch(pre));
          ++j;
        }
        res.pitch.push(tmp);
        ++i;
      }
      return res;
    };

    Generator.prototype.gen_chord = function(dur, options) {
      var chords, fix, i, ii, j, n, new_pre, pre, pre2, r, rc1, rc2, refc, refdur, res, scale_len, seed, seed2, tmp, toPitch, toScale;
      toPitch = this.toPitch;
      toScale = this.toScale;
      chords = _.flatten(ScoreObj.prototype.parseHarmony(options.chords), true);
      scale_len = this.scale.length;
      refc = 0;
      refdur = chords[refc][0];
      res = {
        dur: [],
        pitch: []
      };
      seed = {};
      if ((options.rhythm.seed != null) && (this.seeds != null)) {
        seed = this.seeds[options.rhythm.seed];
      } else {
        seed.dur = options.rhythm[0];
        seed.choices = options.rhythm[1];
        seed.weights = options.rhythm[2];
      }
      seed2 = {};
      if ((options.interval.seed != null) && (this.seeds != null)) {
        seed2 = this.seeds[options.interval.seed];
      } else {
        seed2 = options.interval;
      }
      n = dur / seed.dur >>> 0;
      rc1 = this.rndPicker(seed.choices, seed.weights);
      rc2 = this.rndPicker(seed2.choices, seed2.weights);
      pre = scale_len * 4;
      pre2 = pre;
      i = 0;
      while (i < n) {
        res.dur.push(rc1.gen());
        tmp = [];
        j = 0;
        while (j < res.dur[i].length) {
          if (Math.random() > 0.6) {
            pre += rc2.gen();
            if (pre < 0) {
              pre = 0;
            }
            if (pre > scale_len * 8) {
              pre = scale_len * 8;
            }
            tmp.push(toPitch(pre));
          } else {
            r = Math.random() * 9 >> 0;
            ii = r % 3;
            if (refc + 1 < chords.length && refdur < 0) {
              refdur += chords[++refc][0];
            }
            pre = toPitch(pre);
            new_pre = chords[refc][1] + chords[refc][2][ii] + 12 * (Math.floor(r / 3) - 1);
            while (new_pre - pre > 12) {
              new_pre -= 12;
            }
            while (pre - new_pre > 12) {
              new_pre += 12;
            }
            if (new_pre < 21) {
              new_pre = 21;
            }
            if (new_pre > 108) {
              new_pre = 108;
            }
            tmp.push(new_pre);
            fix = toScale(new_pre);
            pre = fix[0] + fix[1] * scale_len;
          }
          refdur -= options.rhythm[0];
          ++j;
        }
        res.pitch.push(tmp);
        ++i;
      }
      return res;
    };

    Generator.prototype.b2score = function(b, sec, flat) {
      var delta, dur, pitch, ret, tmp;
      dur = flat ? b.dur : _.flatten(b.dur, true);
      pitch = flat ? void 0 : _.flatten(b.pitch, true);
      ret = [];
      tmp = [];
      delta = 0;
      dur.forEach(function(e, j) {
        while (delta + e > sec) {
          tmp.push([sec - delta, pitch[j], true]);
          ret.push(tmp);
          tmp = [];
          e -= sec - delta;
          delta = 0;
        }
        tmp.push([e, pitch[j]]);
        delta += e;
        if (delta === sec) {
          ret.push(tmp);
          tmp = [];
          return delta = 0;
        }
      });
      if (tmp.length > 0) {
        ret.push(tmp);
      }
      return ret;
    };

    Generator.prototype.toScoreObj = function() {
      var b, e0, obj, ref1, res, sec;
      if (res === {}) {
        this.generate();
      }
      sec = this.settings.ctrl_per_beat * this.settings.time_sig[0];
      res = {};
      ref1 = this.res;
      for (e0 in ref1) {
        b = ref1[e0];
        res[e0] = this.b2score(b, sec);
      }
      res = this.schema.structure.map(function(e) {
        return res[e];
      });
      obj = new ScoreObj(this.settings);
      obj.setMelody(_.flatten(res, true), true);
      return obj;
    };

    Generator.prototype.rndPicker = function(choices, weights) {
      var i, k, p, ref1, s;
      s = weights.reduce((function(a, b) {
        return a + b;
      }), 0);
      p = weights.map(function(e) {
        return e / s;
      });
      s = 0;
      for (i = k = 0, ref1 = p.length; k < ref1; i = k += 1) {
        s = (p[i] += s);
      }
      return {
        gen: function() {
          var l, r, ref2;
          r = Math.random();
          for (i = l = 0, ref2 = p.length; l < ref2; i = l += 1) {
            if (r < p[i]) {
              return choices[i];
            }
          }
          return choices[p.length - 1];
        }
      };
    };

    Generator.prototype.gen_random_new = function(end_pos, states, start, constraint) {
      var cur, merge, nexts, picker, res, val;
      res = [];
      cur = {
        state: start.state,
        pos: {
          start: start.pos,
          val: start.val
        }
      };
      while (cur.pos < end_pos) {
        nexts = states[cur.state].choices.map(function(func) {
          var val, weight;
          val = func(cur.pos, cur.val);
          weight = constraint(cur.pos, cur.val, val);
          return [val, weight];
        });
        merge = _.unzip(nexts);
        picker = this.rndPicker(merge[0], merge[1]);
        val = picker.gen();
        if (cur.pos + val.dur >= end_pos) {
          val.dur = end_pos - cur.pos;
        }
        cur.state = states.transition(cur.pos, val);
        cur.pos += val.dur;
        cur.val = val;
        res.push(val);
      }
      return res;
    };

    Generator.prototype.sample_start = {
      state: 'start',
      pos: 0,
      val: {
        dur: 2,
        val: 60,
        weight: []
      }
    };

    Generator.prototype.sample_states = {
      transition: function(pos, val) {},
      'start': {
        choices: function(pos, val) {}
      },
      'middle': {
        choices: function(pos, val) {}
      },
      'other': {
        choices: function(pos, val) {}
      }
    };

    Generator.prototype.sample_constraint = function(pos, preval, val) {
      var weights;
      weights = [4, 2, 4, 6, 6, 8, 1, 8, 6, 6, 2, 2];
      return weights[modulo(val.val - preval.val, 12)];
    };

    return Generator;

  })();

}).call(this);

//# sourceMappingURL=Generator.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, parser, ref1, ref2;

  MG = (ref1 = this.MG) != null ? ref1 : {};

  parser = (ref2 = this.parser) != null ? ref2 : require('./js/parser.js');

  this.ScoreObj = (function() {
    function ScoreObj(options, contents) {
      if (options == null) {
        options = {};
      }
      this.tempo = options.tempo, this.time_sig = options.time_sig, this.key_sig = options.key_sig, this.ctrl_per_beat = options.ctrl_per_beat, this.scale = options.scale, this.volumes = options.volumes, this.instrs = options.instrs;
      if (this.tempo == null) {
        this.tempo = 120;
      }
      if (this.time_sig == null) {
        this.time_sig = [4, 4];
      }
      if (this.key_sig == null) {
        this.key_sig = 'C';
      }
      if (this.ctrl_per_beat == null) {
        this.ctrl_per_beat = 4;
      }
      if (this.scale == null) {
        this.scale = 'maj';
      }
      if (this.volumes == null) {
        this.volumes = [110, 80];
      }
      if (this.instrs == null) {
        this.instrs = [1, 1];
      }
      this.init_ref = MG.scaleToPitch(this.scale, this.key_sig)(4 * MG.scale_class[this.scale].length);
      this.init_ctrlTicks = (60000.0 / this.tempo / this.ctrl_per_beat) >>> 0;
      this.tracks = [];
      this.harmony = [];
      if (contents != null) {
        this.parse(contents);
      }
    }

    ScoreObj.prototype.getSettings = function() {
      return {
        tempo: this.tempo,
        time_sig: this.time_sig,
        key_sig: this.key_sig,
        ctrl_per_beat: this.ctrl_per_beat,
        scale: this.scale,
        volumes: this.volumes
      };
    };

    ScoreObj.prototype.setMelody = function(melody, parsed) {
      if ((parsed != null) && parsed === true) {
        return this.tracks[0] = melody;
      } else {
        return this.tracks[0] = this.parseMelody(melody, {
          scale: MG.scale_class[this.scale],
          init_ref: this.init_ref
        });
      }
    };

    ScoreObj.prototype.setTexture = function(texture, harmony, parsed) {
      if ((parsed != null) && parsed === true) {
        this.harmony = harmony;
        return this.tracks[1] = texture;
      } else {
        this.harmony = this.parseHarmony(harmony);
        return this.tracks[1] = this.parseMelody(texture, {
          harmony: this.harmony
        });
      }
    };

    ScoreObj.prototype.parse = function(options) {
      if (options.melody != null) {
        this.setMelody(options.melody, false);
      }
      if ((options.harmony != null) && options.texture) {
        return this.setTexture(options.texture, options.harmony);
      }
    };

    ScoreObj.prototype.parseMelody = function(m, options) {
      var chorder, e, error, harmony, init_ref, obj, ornamental, ref, refc, res, scale;
      try {
        obj = parser.parse(m.join('\n') + '\n');
      } catch (error) {
        e = error;
        console.log(e.message);
        return;
      }
      ornamental = function(pitch, ref, scale) {
        var p;
        p = typeof pitch === 'number' ? pitch : pitch.original;
        if (p > scale.length) {
          console.log('exceed scale length');
          p = scale.length;
        } else if (p === 0) {
          return 0;
        }
        p = ref + scale[p - 1];
        if (typeof pitch !== 'number') {
          pitch.ornament.forEach(function(e) {
            if (typeof e === 'number') {
              return p += e;
            }
          });
        }
        return p;
      };
      switch (obj.mode) {
        case 'melody':
          scale = options.scale, init_ref = options.init_ref, harmony = options.harmony;
          break;
        case 'harmony':
          harmony = options.harmony;
      }
      refc = null;
      chorder = (function() {
        var bass, c, chord, delta, forward, incr, process, refi;
        c = harmony != null ? _.flatten(harmony, true) : [];
        refi = -1;
        delta = 0;
        bass = function(inv) {
          return (c[refi][1] + c[refi][2][inv]) % 12;
        };
        incr = function() {
          return delta -= c[++refi][0];
        };
        chord = function(inv) {
          return MG.inverted(c[refi][2], inv);
        };
        forward = function(d) {
          return delta += d;
        };
        process = function() {
          var results;
          results = [];
          while (refi < c.length && delta >= 0) {
            results.push(incr());
          }
          return results;
        };
        return {
          bass: bass,
          chord: chord,
          process: process,
          forward: forward
        };
      })();
      if (scale == null) {
        scale = MG.scale_class['maj'];
      }
      if (init_ref == null) {
        init_ref = 60;
      }
      ref = init_ref;
      res = obj.data.map((function(_this) {
        return function(m) {
          var measure;
          measure = [];
          m.forEach(function(e) {
            var bass, chord, k, pitches, results, v;
            if (e.ctrl != null) {
              switch (e.ctrl) {
                case 'reset':
                  return ref = init_ref;
                case 'normal':
                case 'repeat_start':
                  results = [];
                  for (k in e) {
                    v = e[k];
                    switch (k) {
                      case 't':
                        results.push(1);
                        break;
                      case 's':
                        results.push(scale = MG.scale_class[v]);
                        break;
                      case 'k':
                        results.push(1);
                        break;
                      case 'r':
                        results.push(1);
                        break;
                      case 'v':
                        results.push(1);
                        break;
                      case 'o':
                        results.push(1);
                        break;
                      case 'i':
                        results.push(1);
                        break;
                      case 'p':
                        results.push(ref += v);
                        break;
                      default:
                        results.push(void 0);
                    }
                  }
                  return results;
                  break;
                case 'chord':
                  ref = MG.keyToPitch('C3');
                  chorder.process();
                  bass = chorder.bass(e.inv);
                  chord = chorder.chord(e.inv);
                  ref += e.transpose;
                  bass += ref;
                  return refc = e.pitch.map(function(p) {
                    return ornamental(p, bass, chord);
                  });
              }
            } else {
              pitches = [];
              e.pitch.forEach(function(p) {
                if (typeof p === 'string') {

                } else if (refc != null) {
                  if (refc[p - 1] != null) {
                    return pitches.push(refc[p - 1]);
                  }
                } else {
                  return pitches.push(ornamental(p, ref, scale));
                }
              });
              if (typeof e.dur === 'number') {
                measure.push([e.dur, pitches]);
                return chorder.forward(e.dur);
              } else {
                measure.push([e.dur.original, pitches, true]);
                return chorder.forward(e.dur.original);
              }
            }
          });
          return measure;
        };
      })(this));
      return res;
    };

    ScoreObj.prototype.parseHarmony = function(measures) {
      if (typeof measures === 'undefined') {
        console.log('empty harmony');
        return;
      }
      return measures.map(function(e) {
        return e.trim().split(/\s+/).map(function(e2) {
          var chord_info, dur, terms;
          terms = e2.split(',');
          chord_info = MG.getChords(terms[0], 3);
          dur = terms.length >= 2 ? parseInt(terms[1]) : 1;
          return [dur, chord_info[0], chord_info[1]];
        });
      });
    };

    ScoreObj.prototype.toText = function(m) {
      var ref_oct, res, toScale;
      console.log('to score text');
      if (m == null) {
        m = this.tracks[0];
      }
      if (m == null) {
        console.log('null melody');
        return;
      }
      toScale = MG.pitchToScale(this.scale, this.key_sig);
      ref_oct = 4;
      res = m.map(function(e) {
        var ret;
        ret = [];
        e.forEach(function(e1) {
          var o;
          o = '';
          if (typeof e1[1] === 'number') {
            e1[1] = [e1[1]];
          }
          e1[1].forEach(function(e2) {
            var diff, tmp;
            if (e2 < 21 || e2 > 108) {
              return o += '0';
            } else {
              tmp = toScale(e2);
              diff = tmp[1] - ref_oct;
              if (diff < -1 || diff > 1) {
                o += ':';
                while (diff < -1) {
                  o += '-';
                  ref_oct--;
                  diff++;
                }
                while (diff > 1) {
                  o += '+';
                  ref_oct++;
                  diff--;
                }
                o += ' ';
              }
              o += 1 + tmp[0];
              o += {
                '-1': '-',
                1: '+'
              }[diff] || '';
              return o += {
                1: '#',
                2: '##'
              }[tmp[2]] || '';
            }
          });
          if (e1[2] === true) {
            o += '^';
          }
          if (e1[0] > 1) {
            o += ',' + e1[0];
          }
          return ret.push(o);
        });
        return ret.join(' ');
      });
      return res;
    };

    ScoreObj.prototype.toMidi = function() {
      var ctrlTicks, delta, dur, e, i, l, m, q, t, vol;
      console.log('to midi');
      ctrlTicks = this.init_ctrlTicks;
      q = _.flatten(this.tracks[0], true);
      t = this.tracks[1] ? _.flatten(this.tracks[1], true) : null;
      m = new simpMidi();
      delta = 0;
      vol = this.volumes[0];
      i = 0;
      while (i < q.length) {
        e = q[i];
        if (typeof e[1] === 'number' && e[1] < 21 && e[1] > 108) {
          delta += e[0];
        } else {
          dur = e[0];
          while (q[i][2] === true && i + 1 < q.length) {
            dur += q[++i][0];
          }
          m.addNotes(1, dur * ctrlTicks, q[i][1], vol, 0, delta * ctrlTicks);
          delta = 0;
        }
        ++i;
      }
      m.setTimeSignature.apply(m, this.time_sig);
      m.setKeySignature(MG.key_sig[this.key_sig], 'maj');
      m.setTempo(this.tempo);
      m.setDefaultTempo(this.tempo);
      m.setInstr(this.instrs[0]);
      MIDI.programChange(0, this.instrs[0] - 1);
      if (t === null) {
        m.finish();
        return m;
      }
      l = m.addTrack() - 1;
      vol = this.volumes[l - 1];
      m.addEvent(l, 0, 'programChange', l - 1, this.instrs[l - 1] - 1);
      MIDI.programChange(l - 1, this.instrs[l - 1] - 1);
      t.forEach(function(e) {
        return m.addNotes(l, e[0] * ctrlTicks, e[1], vol);
      });
      m.finish();
      return m;
    };

    return ScoreObj;

  })();

}).call(this);

//# sourceMappingURL=ScoreObj.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  this.ScoreRenderer = (function() {
    var dur_mapper;

    function ScoreRenderer(c, p) {
      var pager;
      this.c = document.getElementById(c);
      this.real_ctx = this.c.getContext('2d');
      this.hidden_canvas = document.createElement('canvas');
      this.r = new Vex.Flow.Renderer(this.hidden_canvas, Vex.Flow.Renderer.Backends.CANVAS);
      this.ctx = this.r.getContext();
      this.geo = {
        system_width: 900,
        system_height: 80,
        system_interval: 30,
        left_padding: 25,
        top_padding: 20,
        reserved_width: 55
      };
      this.layout = {
        measure_per_system: 4,
        system_per_page: 6
      };
      this.numPage = 1;
      this.currentPage = 1;
      this.measures = [];
      this.pages = [];
      pager = $('#midi_pager');
      this.UI = {
        prev: pager.find('.prev'),
        next: pager.find('.next'),
        page_num: pager.find('.page_num'),
        page_count: pager.find('.page_count')
      };
      this.UI.prev.on('click', (function(_this) {
        return function() {
          if (_this.currentPage <= 1) {
            return;
          }
          _this.currentPage--;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      this.UI.next.on('click', (function(_this) {
        return function() {
          if (_this.currentPage >= _this.numPage) {
            return;
          }
          _this.currentPage++;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      if (p != null) {
        this.p = new fabric.StaticCanvas(p, {
          width: $('.canvas-wrapper').width(),
          height: $('.canvas-wrapper').height(),
          backgroundColor: 'rgba(240,250,240, 5)'
        });
      }
    }

    ScoreRenderer.prototype.newStave = function(m, k) {
      var i, j, w, x, y;
      i = m % this.layout.measure_per_system;
      j = (Math.floor(m / this.layout.measure_per_system)) % this.layout.system_per_page;
      w = Math.floor((this.geo.system_width - this.geo.reserved_width) / this.layout.measure_per_system);
      x = this.geo.left_padding + i * w;
      y = this.geo.top_padding + j * (this.geo.system_height + this.geo.system_interval);
      if (i === 0) {
        return new Vex.Flow.Stave(x, y, w + this.geo.reserved_width).addClef('treble').addKeySignature(k);
      } else {
        x += this.geo.reserved_width;
        return new Vex.Flow.Stave(x, y, w);
      }
    };

    dur_mapper = ["16", "8", "8d", "4", "4", "4d", "4dd", "2", "2", "2", "2", "2d", "2d", "2dd", "2ddd", "1"];

    ScoreRenderer.prototype.dur_map = function(dur) {
      dur = (dur * 4) >>> 0;
      return dur_mapper[dur - 1];
    };

    ScoreRenderer.prototype.renderPage = function(num) {
      var c, ctx, e, i, l, last, ref, ref1, start;
      if (num < 0 || num >= this.numPage) {
        return;
      }
      if (this.pages[num] != null) {
        this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
        this.real_ctx.drawImage(this.pages[num], 0, 0);
        this.UI.page_num.html(num + 1);
        return;
      }
      console.log('render page', num + 1);
      this.r.resize(1000, 800);
      this.c.width = 1000;
      this.c.height = 800;
      start = this.layout.measure_per_system * this.layout.system_per_page;
      last = (num + 1) * start;
      start = last - start;
      if (last >= this.measures.length) {
        last = this.measures.length;
      }
      ctx = this.ctx;
      for (i = l = ref = start, ref1 = last; l < ref1; i = l += 1) {
        e = this.measures[i];
        e.stave.setContext(ctx).draw();
        e.voices.forEach(function(v) {
          return v.draw(ctx, e.stave);
        });
        e.beams.forEach(function(v) {
          return v.setContext(ctx).draw();
        });
      }
      c = document.createElement('canvas');
      c.width = 1000;
      c.height = 800;
      c.getContext('2d').drawImage(this.hidden_canvas, 0, 0);
      this.pages[num] = c;
      this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
      this.real_ctx.drawImage(this.pages[num], 0, 0);
      return this.UI.page_num.html(num + 1);
    };

    ScoreRenderer.prototype.render = function(score, contents) {
      var beams, dur_tot, formatter, i, l, melody, notes, num_beats, raw_w, ref, s, sharp, stave, toScale, voice, w;
      raw_w = Math.floor((this.geo.system_width - this.geo.reserved_width) / this.layout.measure_per_system);
      s = this.s = new ScoreObj(score, contents);
      sharp = MG.key_sig[score.key_sig] >= 0;
      toScale = MG.pitchToScale(score.scale, s.key_sig);
      this.measures = [];
      melody = s.tracks[0];
      for (i = l = 0, ref = melody.length; l < ref; i = l += 1) {
        stave = this.newStave(i, s.key_sig);
        if (i === 0) {
          stave.addTimeSignature(s.time_sig.join('/'));
        }
        dur_tot = 0;
        notes = melody[i].map((function(_this) {
          return function(e) {
            var duration, keys, res;
            dur_tot += e[0];
            duration = _this.dur_map(e[0] / s.ctrl_per_beat);
            keys = [];
            if (typeof e[1] === 'number') {
              e[1] = [e[1]];
            }
            e[1].forEach(function(e1) {
              var key, tmp;
              if (e1 < 21 || e1 > 108) {
                return;
              }
              tmp = toScale(e1);
              key = MG.scale_keys[s.key_sig][tmp[0]];
              key += '/' + ((Math.floor(e1 / 12)) - 1 + ({
                'Cb': 1,
                'B#': -1
              }[key] || 0));
              if (tmp[2] !== 0) {
                key = MG.pitchToKey(e1, sharp).join('/');
              }
              if (key != null) {
                return keys.push(key);
              }
            });
            if (keys.length <= 0) {
              keys.push('Bb/4');
              duration += 'r';
            }
            res = new Vex.Flow.StaveNote({
              keys: keys,
              duration: duration,
              auto_stem: true
            });
            if (duration.substr(-1) === 'd') {
              res.addDotToAll();
              if (duration.substr(-2, 1) === 'd') {
                res.addDotToAll();
              }
            }
            return res;
          };
        })(this));
        num_beats = Math.floor(dur_tot / s.ctrl_per_beat);
        voice = new Vex.Flow.Voice({
          num_beats: num_beats,
          beat_value: s.time_sig[1],
          resolution: Vex.Flow.RESOLUTION
        });
        voice.addTickables(notes);
        Vex.Flow.Accidental.applyAccidentals([voice], s.key_sig);
        beams = Vex.Flow.Beam.applyAndGetBeams(voice);
        w = raw_w;
        if (i % this.layout.measure_per_system === 0) {
          w -= this.geo.reserved_width;
        }
        if (i === 0) {
          w -= 10;
        }
        formatter = new Vex.Flow.Formatter().joinVoices([voice]).format([voice], w - 10);
        this.measures.push({
          voices: [voice],
          stave: stave,
          beams: beams
        });
      }
      this.numPage = Math.ceil(this.measures.length / this.layout.measure_per_system / this.layout.system_per_page);
      this.UI.page_count.html(this.numPage);
      this.currentPage = 1;
      this.pages.forEach((function(_this) {
        return function(c, i) {
          return delete _this.pages[i];
        };
      })(this));
      this.pages = [];
      return this.renderPage(this.currentPage - 1);
    };

    return ScoreRenderer;

  })();

}).call(this);

//# sourceMappingURL=ScoreRenderer.js.map
;function dataURLtoBlob(dataurl) {
	var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
			bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
	while(n--){
		u8arr[n] = bstr.charCodeAt(n);
	}
	return new Blob([u8arr], {type:mime});
}
var seqPlayer = {
	channel:0,
	harmony:[],
	instrs: [],
	tracks: [],
	playing:[],
	cur_i:[],
	midi: null,
	raw_midi: "",
	play:function(n){
		n = n || 0;
		if(!this.tracks[n] || this.tracks[n].length<=0){
			return;
		}
		this.playing[n] = true;
		var q = this.tracks[n];
		var nexti = this.cur_i[n];

		var cur = q[nexti];
		nexti++;
		var channel = n;

		function loop(){
			if(cur[0]>0){ // not tied
				var notes = typeof cur[1] == 'number'? [cur[1]] : cur[1];
				notes.forEach(function(e){
					if(e>=21 && e<=108) {
						MIDI.noteOn(channel, e, cur[2]);
					}
				});
			}
        	setTimeout(function(){
				var notes = typeof cur[1] == 'number'? [cur[1]] : cur[1];
        		if(nexti < 0){

					notes.forEach(function(e){
						if(e>=21 && e<=108){
							MIDI.noteOff(channel,e);
						}
					});

        			seqPlayer.playing[n] = false;
        			seqPlayer.onend(n);
        		}else{

        			if(q[nexti][0]>0){
						notes.forEach(function(e){
							if(e>=21 && e<= 108){
								MIDI.noteOff(channel,e);
							}
						});

        		    }
        		    cur = q[nexti];
					if(seqPlayer.playing[n]){
						nexti++;
						if(nexti>= q.length){
							nexti = -1;
							seqPlayer.cur_i[n] = 0;
						}
					}else{
						seqPlayer.cur_i[n] = nexti;
						nexti = -1;
					}
        		    //log('next',q[nexti]);
        		    loop();
        	    }
        	},cur[0]>=0? cur[0]: -cur[0]);
				

	    }
	    setTimeout(loop, 0);



	},
	toQ: function(arr, ctrlTicks, vol){
		var vol = vol || 110;
		var m = _.flatten(arr, true);
		var res = [];
		for (var j = 0; j < m.length; ++j) {
			var delta = m[j][0];
			while (m[j][2] == true && j + 1 < m.length) {
				j++;
				delta += m[j][0];
			}
			res.push([delta * ctrlTicks, m[j][1], vol])
		}
		return res;

	},
	pause:function(n){
		var n = n || 0;
		if(n >= this.tracks.length){
			return;
		}
		this.playing[n] = false;

	},
	stop:function(n){
		var n = n || 0;
		if(n >= this.tracks.length){
			return;
		}
		this.playing[n] = false;
		this.cur_i[n] = 0;

	},
	onend:function(){},
    fromScore:function (src, contents) {
        var obj = new ScoreObj(src,contents);
		var ctrlTicks = obj.init_ctrlTicks;
		// TODO: add volume control
		var q = this.toQ(obj.tracks[0], ctrlTicks, src.volumes[0]);
		var t = this.toQ(obj.tracks[1], ctrlTicks, src.volumes[1]);
		this.tracks = [];
		this.instrs = obj.instrs;
		this.tracks.push(q, t);
		this.playing = [false, false];
		this.cur_i = [0,0];
        this.harmony = obj.harmony;
        this.midi = obj.toMidi();
        this.raw_midi = MidiWriter(this.midi);

    },
	saveMidi:function(){
		if(this.raw_midi.length<1) return;
		var bf = new Uint8Array(this.raw_midi.split("").map(function(e){return e.charCodeAt(0);}));
		saveAs(new File([bf], 'sample.mid', {type:"audio/midi"}));
	}
}



var TEST = TEST || {};



TEST.analysis = function(data, ctrl_per_beat){
	var data = data || MIDI.Player.currentData;
	var ctrl_per_beat = ctrl_per_beat || 4;
	var m = MidiFile(data);
	var q = simpMidi.prototype.quantize.call(m, ctrl_per_beat);

	var tracks =  q.map(function(track){
		var res = [];
		var tmp = [];
		// handle
		var delta = 0;
		track.forEach(function(e){
			if(e[0]>delta){
				if(tmp.length>0){
					res.push([e[0]-delta, tmp]);
					tmp = [];
				}else{
					res.push([e[0]-delta, [0]]);//rest
				}
				delta = e[0];
			}else{
				// ignore 'noteOff' and velocity == 0
				if(e[1] == 'noteOn' && e[3] != 0){
					tmp.push(e[2]); //noteNumber
				}
			}
		});
		res = _.unzip(res);
		res = {dur:res[0], pitch:res[1]};
		return Generator.prototype.b2score.call({},res,ctrl_per_beat);
	});
	var info =  tracks.map(function(e){
		return midi_statistics(e);
	});

	return info;
};

function midi_statistics(obj){
	function obj_sort(data){
		var k = Object.keys(data);
		var v = k.map(function(key){return data[key]});
		var kv = _.zip(k,v);
		kv.sort(function(a,b){return b[1]-a[1]});// decending
		return kv;
	}
	var info = {rhythm:{}, melody:{one:{}, two:{}}};
	var one = {}, two = {};
	var n_one = 0, n_two = 0;
	obj.forEach(function(e){
		var measure = _.unzip(e);
		var r = measure[0];
		info.rhythm[r] = 1+ (info.rhythm[r] || 0);
		r = measure[1];
		if(r.length<2) return;
		var c = [r[0] % 12, (r[1]-r[0])%12];
		one[c] = 1+ (one[c] || 0); n_one ++;
		for(var i=2;i < r.length;++i){
			c = [r[i-1]%12, (r[i]-r[i-1])%12];
			one[c] = 1 + (one[c]||0); n_one ++;
			c = [r[i-2] % 12, (r[i-1] - r[i-2]) % 12, c[1]];
			two[c] = 1 + (two[c]||0); n_two ++;
		}
	});

	info = {
		rhythm: obj_sort(info.rhythm),
		melody: {
			one: obj_sort(one),
			two: obj_sort(two),
			n: [0,n_one, n_two]
		}
	};
	return info;


}


function wavFile(data){
	var header = new Int8Array([
		82, 73, 70, 70, // RIFF
		255, 255, 255, 255, // 36 +
		87, 65, 86, 69, // WAVE
		102, 109, 116, 32, // "fmt "
		16, 0, 0, 0, // fmt chunk size
		1, 0, 2, 0, // pcm, 2 channel
		128, 187, 0, 0, // sampleps
		0, 119, 1, 0, // bytes per sec
		4, 0, 16, 0, // blockAlign, bits per sample
		100, 97, 116, 97, // data
		255, 255, 255, 255 // datasize
	]);

	var bL = data[0], bR = data[1];
	var len = bL.length, max = 0x7fff-1;
	var buffer = new Int16Array(len*2);
	for(var i=0;i<len;++i){
		buffer[i*2] = Math.floor(max * bL[i]);
		buffer[i*2+1] = Math.floor(max * bR[i]);
	}


	function setHeader(datasize, sampleps){
		var dv = new DataView(header.buffer);
		dv.setInt32(40,datasize, true);
		dv.setInt32(4,datasize+36, true);
		dv.setInt32(24,sampleps, true);
	}
	function toBlob(){
		setHeader(4 * len, 44100);// datasize = blockAlign * length
		return new Blob([header, buffer], {type:'audio/wav'});
	}
	return toBlob();

}
function midi2wav(midifile, sampleps){
	var sampleps = sampleps || 44100;
	// currently ignore setTempo
	var rep = new Replayer(midifile, 1, null);
	var data = rep.getData();
	var endTime = 500.0 * 2; // extra 500ms *2
	data.forEach(function(e){
		endTime += e[1];
	});


	var len = Math.floor(sampleps/1000 * endTime);
	console.log('length', len);
	var chL = new Float32Array(len), chR = new Float32Array(len);
	var curTime = 500.0; // in miliseconds
	var sources = {};
	function noteOn(channelId, noteId, velocity){
		var channel = MIDI.channels[channelId];
		var instrument = channel.program;
		var bufferId = instrument + 'x' + noteId;
		var buffer = MIDI.audioBuffers[bufferId];
		if(buffer == null){
			console.log('no buffer', bufferId);
			return;
		}
		// check if already noteOn;
		sources[channelId + 'x' + noteId] = {buffer:buffer, cur_i:0, vol:velocity/127, fade_out:-1};

	}
	function noteOff(channelId, noteId){
		var source = sources[channelId + 'x' + noteId];
		if(source){
			var fade_time = source.vol * 0.15; // should get from metadata
			source.fade_out = Math.floor(fade_time * sampleps);
		}

	}
	function forward(n){
		if(n<=0){
			return ;
		}

		var start_i = Math.floor(curTime * sampleps / 1000);
		//console.log('forward', n, start_i);

		for(var s in sources){
			var source = sources[s];
			var bL = source.buffer.getChannelData(0),
					bR = source.buffer.getChannelData(1),
					vol = source.vol;
			var i_to = start_i, i_from = source.cur_i;
			var real_n = n;
			if(i_from + real_n> bL.length){
				real_n = bL.length - i_from;
			}
			if(source.fade_out<0){
				// noteOn
				for(var i=0;i<real_n;++i, ++i_to, ++i_from){
					chL[i_to] += bL[i_from] * vol;
					chR[i_to] += bR[i_from] * vol;
				}
			}else{
				// noteOff, fade out
				var delta = vol/source.fade_out;
				if(source.fade_out<real_n){
					real_n = source.fade_out;
				}
				for(var i=0;i<real_n;++i, ++i_to, ++i_from){
					chL[i_to] += bL[i_from] * vol;
					chR[i_to] += bR[i_from] * vol;
					vol -= delta;
				}
				source.fade_out -= real_n;
				source.vol = vol;


			}
			source.cur_i = i_from;
			if(source.fade_out == 0 || source.cur_i >= bL.length){
				delete sources[s];
			}


		}


	}
	function processing(e){
		// TODO: add fade out
		forward(Math.floor(sampleps/1000 * e[1]));
		curTime += e[1];
		if(e[0].event.type !== 'channel'){
			return; //ignore non-channel event
		}
		var event = e[0].event;
		var channelId = event.channel;
		var channel = MIDI.channels[channelId];

		switch(event.subtype){
			case 'controller':
				MIDI.setController(channelId, event.controllerType, event.value, 0);// should check
				break;
			case 'programChange':
				MIDI.programChange(channelId, event.programNumber, 0);
				console.log('to mp3, programChange', event.programNumber);
				break;
			case 'pitchBend':
				MIDI.pitchBend(channelId, event.value, 0);
				break;
			case 'noteOn':
				if (channel.mute) break;
				noteOn(channelId, event.noteNumber, event.velocity);
				break;
			case 'noteOff':
				if (channel.mute) break;
				noteOff(channelId, event.noteNumber);
				break;
			default:
				break;
		}
	}

	// load all instruments
	MIDI.loadPlugin({
		instruments: MIDI.Player.getFileInstruments(data)
	}, function(){
		// after success
		console.log('loadededed');

	});
	data.forEach(processing);
	console.log('midi to mp3 processed');

	return [chL, chR];
}



    





;
//
// If absolute URL from the remote server is provided, configure the CORS
// header on that server.
//



//
// Disable workers to avoid yet another cross-origin issue (workers need
// the URL of the script to be loaded, and dynamically loading a cross-origin
// script does not work).
//
// PDFJS.disableWorker = true;

//
// In cases when the pdf.worker.js is located at the different folder than the
// pdf.js's one, or the pdf.js is executed via eval(), the workerSrc property
// shall be specified.
//
// PDFJS.workerSrc = '../../build/pdf.worker.js';




/**
 * Returns scale factor for the canvas. It makes sense for the HiDPI displays.
 * @return {Object} The object with horizontal (sx) and vertical (sy)
                    scales. The scaled property is set to false if scaling is
                    not required, true otherwise.
 */
function getOutputScale(ctx) {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                          ctx.mozBackingStorePixelRatio ||
                          ctx.msBackingStorePixelRatio ||
                          ctx.oBackingStorePixelRatio ||
                          ctx.backingStorePixelRatio || 1;
  var pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}

(function(self) {

  var pdfDoc = null,
      pageNum = 1,
      pageRendering = false,
      pageNumPending = null,
      scale = 5,
      wrapper = document.getElementById('canvas-wrapper'),
      the_canvas = document.getElementById('the-canvas'),
      ctx = the_canvas.getContext('2d');
  var pdf_canvas_buffers = [];
  the_canvas.style.width = "100%"; //(ratio * 100) + "%";

  /**
   * Get page info from document, resize canvas accordingly, and render page.
   * @param num Page number.
   */
  function renderPage(num) {
    // TODO: limit buffer size
    console.log('pdf render page', num);
    pageRendering = true;
    // Using promise to fetch the page
    pdfDoc.getPage(num).then(function (page) {
      var ratio = 8;
      var viewport = page.getViewport(scale);

      //console.log(viewport.width,viewport);
      var canvas = document.createElement('canvas');
      canvas.height = viewport.height;
      canvas.width = viewport.width;

      //canvas.style.transform = "scale(" + 1/ratio + ', ' + 1/ratio + ")" ;
      //canvas.style.transformOrigin = "0% 0%";
      //wrapper.style.width = Math.floor(viewport.width/ratio) + 'pt';
      //wrapper.style.height = Math.floor(viewport.height/ratio)+ 'pt';


      // Render PDF page into canvas context
      var renderContext = {
        canvasContext: canvas.getContext('2d'),
        viewport: viewport
      };
      var renderTask = page.render(renderContext);


      // Wait for rendering to finish
      renderTask.promise.then(function () {
        pageRendering = false;
        pdf_canvas_buffers[num - 1] = canvas;

        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pageNumPending);
          pageNumPending = null;
        }
      });


    });

  }

  /**
   * If another page rendering in progress, waits until the rendering is
   * finised. Otherwise, executes rendering immediately.
   */
  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPage(num);
    }
  }


  var pager = $('#pdf_pager');
  var UI = {
    prev: pager.find('.prev'),
    next: pager.find('.next'),
    page_num: pager.find('.page_num'),
    page_count: pager.find('.page_count')
  };

  /**
   * Displays previous page.
   */
  UI.prev.on('click', function () {
    if (pageNum <= 1) {
      return;
    }
    pageNum--;
    if (pdf_canvas_buffers[pageNum - 1] == null) {
      queueRenderPage(pageNum);
    }
    showPage(pageNum);
  });

  /**
   * Displays next page.
   */

  UI.next.on('click', function () {
    if (pageNum >= pdfDoc.numPages) {
      return;
    }
    pageNum++;
    if (pdf_canvas_buffers[pageNum - 1] == null) {
      queueRenderPage(pageNum);
    }
    showPage(pageNum); // should set Timeout
    if (pageNum + 1 < pdfDoc.numPages && pdf_canvas_buffers[pageNum] == null) {
      queueRenderPage(pageNum + 1); //pre rendering
    }
  });

  function showPage(num) {
    var canvas = pdf_canvas_buffers[num - 1];
    if (canvas == null) {
      console.log('null canvas');
      setTimeout(function () {
        showPage(num);
      }, 100);
      return false
    }
    the_canvas.width = canvas.width;
    the_canvas.height = canvas.height;
    ctx.drawImage(canvas, 0, 0);
    // Update page counters
    UI.page_num.html(pageNum);
    return true;
  }

  /**
   * Asynchronously downloads PDF.
   */
  function load_pdf(pdfurl) {
    PDFJS.getDocument(pdfurl).then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      pdf_canvas_buffers = [];
      pageNum = 1;
      UI.page_count.html(pdfDoc.numPages);
      // Initial/first page rendering
      renderPage(pageNum);
      showPage(pageNum);
      queueRenderPage(pageNum + 1);
    });
  }
  // export functionality
  self.load_pdf = load_pdf;

})(this);;
var keyrange = 23;
var pressed = [];


function make_keyboard(n_octaves, x0, ww, bw){
    var black_key_offset = [0,1,3,4,5];
    var res = '';
    for(var i=0;i<n_octaves;++i){
        for(j=0;j<7;++j){
            res += '<button type="button" class="white_key kb" data-piano-key-number="'+(12*i+white_key_num[j])+'" style="left:';
            res += (x0+(i*7+j)*ww) +'px"></button>';

        }
        for(var j=0;j<5;++j){
            res += '<button type="button" class="black_key kb" data-piano-key-number="'+(12*i+black_key_num[j])+'" style="left:';
            res += (x0+(i*7+black_key_offset[j])*ww+ww-bw/2) +'px"></button>';

        }

    }
    keyrange = n_octaves*12-1;
    return res;


}

function make_modeboard(keys){
    var res = '<input type="radio" name="musicMode" value="single" checked>Single note<br>\n';
    for(var i in keys){
        var j = chord_name[keys[i]];
        if(j != undefined){
            res += '<input type="radio" name="musicMode" value="' + (keys[i]) + '">'+ (j) + '<br>\n';
        }
    }
    return res;
}


var this_pitch, this_key, this_amplitude;
var lowest_pitch=60; // The MIDI pitch number for the first (left) keyboard key



function pressing(){
    var mode = $(":radio[name=musicMode]:checked").val();
    pressed = mode == "single"? [0]: chord_num[mode];

    pressed.forEach(function(el){
        if(this_pitch+el>108) return;
        MIDI.noteOn(0, this_pitch+el, this_amplitude);
        var tgt = $('button[data-piano-key-number='+(this_key+el)+']');
        tgt.css("background", tgt.hasClass("white_key")? "#DDD": "#444");
    });
}

function handlePianoKeyPress(evt) {

    lowest_pitch = parseInt($("input#lowest_pitch").val());
    if(lowest_pitch< 21){
        lowest_pitch = 21;
        $("input#lowest_pitch").val(21);
    }
    if(lowest_pitch+keyrange>108){
        lowest_pitch = 108-keyrange;
        $("input#lowest_pitch").val(108-keyrange)
    }

    // Determine which piano key has been pressed.
    // 'evt.target' tells us exactly which item triggered this function.
    // The piano key number is taken from the 'data-piano-key-number' attribute of each button.
    // The piano key number is a value in the range 0 to keyrange inclusive.
    this_key = parseInt($(evt.target).data("piano-key-number"));
    this_pitch = lowest_pitch + this_key;

    // Extract the amplitude value from the slider
    this_amplitude = parseInt($("#amplitude").val());

    // Use the two numbers to start a MIDI note
    // Handle chord mode
    pressing();
};



function handlePianoKeyRelease(evt) {
    if(pressed.length == 0) return;
    // Show a simple message in the console
    if(evt!=null) console.log("Key release event!");
    // Send the note off message to match the pitch of the current note on event
    pressed.forEach(function(el){
        if(this_pitch+el>108) return;
        MIDI.noteOff(0, this_pitch+el);
        var tgt = $('button[data-piano-key-number='+(this_key+el)+']');
        tgt.css("background", tgt.hasClass("white_key")? "white": "black");
    });
    pressed = [];
};

