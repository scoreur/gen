// Generated by CoffeeScript 1.10.0
(function() {
  var MG, alias, ex, ref1,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref1 = this.MG) != null ? ref1 : {};

  MG.instrs = {
    'Piano': ['1 Acoustic Grand Piano', '2 Bright Acoustic Piano', '3 Electric Grand Piano', '4 Honky-tonk Piano', '5 Electric Piano 1', '6 Electric Piano 2', '7 Harpsichord', '8 Clavinet'],
    'Chromatic Percussion': ['9 Celesta', '10 Glockenspiel', '11 Music Box', '12 Vibraphone', '13 Marimba', '14 Xylophone', '15 Tubular Bells', '16 Dulcimer'],
    'Organ': ['17 Drawbar Organ', '18 Percussive Organ', '19 Rock Organ', '20 Church Organ', '21 Reed Organ', '22 Accordion', '23 Harmonica', '24 Tango Accordion'],
    'Guitar': ['25 Acoustic Guitar (nylon)', '26 Acoustic Guitar (steel)', '27 Electric Guitar (jazz)', '28 Electric Guitar (clean)', '29 Electric Guitar (muted)', '30 Overdriven Guitar', '31 Distortion Guitar', '32 Guitar Harmonics'],
    'Bass': ['33 Acoustic Bass', '34 Electric Bass (finger)', '35 Electric Bass (pick)', '36 Fretless Bass', '37 Slap Bass 1', '38 Slap Bass 2', '39 Synth Bass 1', '40 Synth Bass 2'],
    'Strings': ['41 Violin', '42 Viola', '43 Cello', '44 Contrabass', '45 Tremolo Strings', '46 Pizzicato Strings', '47 Orchestral Harp', '48 Timpani'],
    'Ensemble': ['49 String Ensemble 1', '50 String Ensemble 2', '51 Synth Strings 1', '52 Synth Strings 2', '53 Choir Aahs', '54 Voice Oohs', '55 Synth Choir', '56 Orchestra Hit'],
    'Brass': ['57 Trumpet', '58 Trombone', '59 Tuba', '60 Muted Trumpet', '61 French Horn', '62 Brass Section', '63 Synth Brass 1', '64 Synth Brass 2'],
    'Reed': ['65 Soprano Sax', '66 Alto Sax', '67 Tenor Sax', '68 Baritone Sax', '69 Oboe', '70 English Horn', '71 Bassoon', '72 Clarinet'],
    'Pipe': ['73 Piccolo', '74 Flute', '75 Recorder', '76 Pan Flute', '77 Blown Bottle', '78 Shakuhachi', '79 Whistle', '80 Ocarina'],
    'Synth Lead': ['81 Lead 1 (square)', '82 Lead 2 (sawtooth)', '83 Lead 3 (calliope)', '84 Lead 4 (chiff)', '85 Lead 5 (charang)', '86 Lead 6 (voice)', '87 Lead 7 (fifths)', '88 Lead 8 (bass + lead)'],
    'Synth Pad': ['89 Pad 1 (new age)', '90 Pad 2 (warm)', '91 Pad 3 (polysynth)', '92 Pad 4 (choir)', '93 Pad 5 (bowed)', '94 Pad 6 (metallic)', '95 Pad 7 (halo)', '96 Pad 8 (sweep)'],
    'Synth Effects': ['97 FX 1 (rain)', '98 FX 2 (soundtrack)', '99 FX 3 (crystal)', '100 FX 4 (atmosphere)', '101 FX 5 (brightness)', '102 FX 6 (goblins)', '103 FX 7 (echoes)', '104 FX 8 (sci-fi)'],
    'Ethnic': ['105 Sitar', '106 Banjo', '107 Shamisen', '108 Koto', '109 Kalimba', '110 Bagpipe', '111 Fiddle', '112 Shanai'],
    'Percussive': ['113 Tinkle Bell', '114 Agogo', '115 Steel Drums', '116 Woodblock', '117 Taiko Drum', '118 Melodic Tom', '119 Synth Drum'],
    'Sound effects': ['120 Reverse Cymbal', '121 Guitar Fret Noise', '122 Breath Noise', '123 Seashore', '124 Bird Tweet', '125 Telephone Ring', '126 Helicopter', '127 Applause', '128 Gunshot']
  };

  this.chord_num = MG.chord_class = {
    "maj": [0, 4, 7],
    "min": [0, 3, 7],
    "dim": [0, 3, 6],
    "aug": [0, 4, 8],
    "dom7": [0, 4, 7, 10],
    "maj7": [0, 4, 7, 11],
    "min7": [0, 3, 7, 10],
    "aug7": [0, 4, 8, 10],
    "dim7": [0, 3, 6, 9]
  };

  MG.inverted = function(arr, n) {
    var i, m, ref2, ret;
    if (n == null) {
      n = 1;
    }
    n = modulo(n, arr.length);
    ret = new Array(arr.length);
    for (i = m = 0, ref2 = arr.length; m < ref2; i = m += 1) {
      ret[i] = modulo(arr[(n + i) % arr.length] - arr[n], 12);
    }
    return ret;
  };

  MG.chords = (function() {
    var c, ci, i, m, ref2, ref3, res, v;
    res = {};
    ref2 = MG.chord_class;
    for (c in ref2) {
      v = ref2[c];
      ci = c + '';
      for (i = m = 0, ref3 = v.length; m < ref3; i = m += 1) {
        res[ci] = MG.inverted(v, i);
        ci += 'i';
      }
    }
    return res;
  })();

  MG.interval_class = {
    'u1': 0,
    'm2': 1,
    'M2': 2,
    'm3': 3,
    'M3': 4,
    'p4': 5,
    'a4': 6,
    'd5': 6,
    'p5': 7,
    'm6': 8,
    'M6': 9,
    'm7': 10,
    'M7': 11,
    'o8': 12
  };

  MG.key_class = (function() {
    var kn1, kn2, res;
    kn1 = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    kn2 = ['B#', 'C#', 'D', 'D#', 'Fb', 'E#', 'F#', 'G', 'G#', 'A', 'A#', 'Cb'];
    res = {};
    kn1.forEach(function(e, i) {
      res[e] = i;
    });
    kn2.forEach(function(e, i) {
      res[e] = i;
    });
    return res;
  })();

  MG.scale_class = {
    'maj': [0, 2, 4, 5, 7, 9, 11],
    'min': [0, 2, 3, 5, 7, 8, 10],
    'min_harmonic': [0, 2, 3, 5, 7, 8, 11],
    'min_melodic': [0, 2, 3, 5, 7, 9, 11],
    'chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    'octatonic': [0, 1, 3, 4, 6, 7, 9, 10],
    'whole': [0, 2, 4, 6, 8, 10],
    'dorian': [0, 2, 3, 5, 7, 9, 10],
    'lydian': [0, 2, 4, 6, 7, 9, 11],
    'pent': [0, 2, 4, 7, 9],
    'pent_min': [0, 3, 5, 7, 10],
    'zhi': [0, 2, 5, 7, 9],
    'blues': [0, 3, 5, 6, 7, 10]
  };

  this.white_key_num = [0, 2, 4, 5, 7, 9, 11];

  this.black_key_num = [1, 3, 6, 8, 10];

  MG.scaleToPitch = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(num) {
      return ref + (Math.floor(num / scale.length)) * 12 + scale[modulo(num, scale.length)] + 12;
    };
  };

  MG.pitchToScale = function(mode, tonic) {
    var ref, ref2, ref3, scale;
    scale = (ref2 = MG.scale_class[mode]) != null ? ref2 : MG.scale_class['maj'];
    ref = (ref3 = MG.key_class[tonic]) != null ? ref3 : 0;
    return function(pitch) {
      var i, m, oct, ref4;
      pitch -= ref;
      oct = Math.floor(pitch / 12) - 1;
      pitch = modulo(pitch, 12);
      for (i = m = ref4 = scale.length - 1; m >= 0; i = m += -1) {
        if (pitch >= scale[i]) {
          return [i, oct, pitch - scale[i]];
        }
      }
      return [0, oct, pitch - scale[0]];
    };
  };

  MG.testPitchScaleConversion = function() {
    var flag, i, j, m, mode, ref2, scale, tmp, toPitch, toScale, tonic;
    ref2 = MG.scale_class;
    for (scale in ref2) {
      mode = ref2[scale];
      flag = true;
      for (tonic in MG.key_class) {
        toPitch = MG.scaleToPitch(scale, tonic);
        toScale = MG.pitchToScale(scale, tonic);
        for (i = m = 21; m <= 108; i = ++m) {
          tmp = toScale(i);
          j = toPitch(tmp[0] + mode.length * tmp[1]) + tmp[2];
          if (j !== i) {
            flag = false;
            console.log(tonic, scale, i, tmp, j);
          }
        }
      }
      if (flag) {
        console.log(scale, 'success');
      }
    }
  };

  MG.keyToPitch = function(key) {
    var key_class, oct, ref, ref2, ref3;
    key_class = /[CDEFGAB][#b]{0,2}/.exec(key)[0];
    if (key_class == null) {
      key_class = 'C';
    }
    ref = (ref2 = MG.key_class[key_class]) != null ? ref2 : 0;
    oct = /[0-9]/.exec(key)[0];
    oct = (ref3 = parseInt(oct)) != null ? ref3 : 4;
    return 12 + ref + oct * 12;
  };

  MG.pitchToKey = function(pitch, sharp, nooct) {
    var kn, ref;
    if (pitch < 21 || pitch > 108) {
      return void 0;
    }
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    if (sharp === true) {
      kn = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    }
    ref = pitch % 12;
    if (nooct != null) {
      return kn[ref];
    } else {
      return [kn[ref], Math.floor(pitch / 12) - 1];
    }
  };

  MG.testPitchKeyConversion = function() {
    var flag, i, j, m, tmp;
    flag = true;
    for (i = m = 21; m <= 108; i = ++m) {
      tmp = MG.pitchToKey(i, true);
      j = MG.keyToPitch(tmp[0] + tmp[1]);
      if (j !== i) {
        flag = false;
        console.log(i, tmp, j);
      }
    }
    if (flag) {
      console.log('success');
    }
  };

  MG.transposer = function(scale_name, key_sig) {
    var scale_len, toPitch, toScale;
    if (scale_name == null) {
      scale_name = 'chromatic';
    }
    console.log(scale_name, 'transposer');
    if (key_sig == null) {
      key_sig = 'C';
    }
    scale_len = MG.scale_class[scale_name].length;
    toScale = MG.pitchToScale(scale_name, key_sig);
    toPitch = MG.scaleToPitch(scale_name, key_sig);
    return function(pitch, diff) {
      var tmp;
      tmp = toScale(pitch);
      return toPitch(tmp[0] + tmp[1] * scale_len + diff) + tmp[2];
    };
  };

  ex = /[ABCDEFG][b#]{0,2}/;

  alias = {
    '7': 'dom7',
    '': 'maj',
    'M': 'maj',
    'm': 'min',
    'mi': 'min',
    'm7': 'min7'
  };

  MG.getChords = function(chord_str, oct) {
    var chord_name, chord_pitches, ref2, root, root_pitch;
    if (oct == null) {
      oct = 4;
    }
    root = ex.exec(chord_str)[0];
    root_pitch = MG.keyToPitch(root + oct);
    chord_name = chord_str.substr(ex.lastIndex + root.length);
    chord_name = (ref2 = alias[chord_name]) != null ? ref2 : chord_name;
    chord_pitches = MG.chords[chord_name] || MG.chords['maj'];
    return [root_pitch, chord_pitches];
  };

  MG.key_sig_rev = {};

  MG.key_sig = (function() {
    var i, j, kn, l, m, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    for (i = m = 0; m < 12; i = m += 1) {
      j = (i * 7) % 12;
      l = (i + 6) % 12 - 6;
      res[kn[j]] = l;
      MG.key_sig_rev[l] = kn[j];
    }
    res['F#'] = 6;
    MG.key_sig_rev[6] = 'F#';
    return res;
  })();

  MG.keyNames = (function() {
    var ref, res;
    res = new Array(12).fill(0).map(function(e) {
      return [];
    });
    ref = MG.scale_class['maj'];
    "CDEFGAB".split("").forEach(function(key, i) {
      res[modulo(ref[i] - 2, 12)].push(key + 'bb');
      res[modulo(ref[i] - 1, 12)].push(key + 'b');
      res[ref[i] % 12].push(key);
      res[(ref[i] + 1) % 12].push(key + '#');
      return res[(ref[i] + 2) % 12].push(key + '##');
    });
    return res;
  })();

  MG.scale_keys = (function() {
    var kn, ref, res;
    kn = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    res = {};
    res['C'] = "CDEFGAB".split("");
    ref = MG.scale_class['maj'];
    kn.forEach(function(e, i) {
      var j, k, m, notes, pitch, ref2, results, v;
      if (e === 'C') {
        return;
      }
      res[e] = [e];
      results = [];
      for (j = m = 1, ref2 = ref.length; m < ref2; j = m += 1) {
        pitch = (i + ref[j]) % 12;
        notes = MG.keyNames[pitch];
        results.push((function() {
          var results1;
          results1 = [];
          for (k in notes) {
            v = notes[k];
            if (v[0] === res['C'][(res['C'].indexOf(e[0]) + j) % 7]) {
              res[e].push(v);
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    });
    return res;
  })();

  this.chord_name = MG.chord_class_label = {
    "maj": "Major triad",
    "min": "Minor triad",
    "aug": "Augmented triad",
    "dim": "Diminished triad",
    "dom7": "Dominant seventh chord",
    "maj7": "Major seventh chord",
    "min7": "Minor seventh chord",
    "aug7": "Augmented seventh chord",
    "dim7": "Diminished seventh chord"
  };

  this.score_summer = MG.score_summer = {
    settings: {
      tempo: 120,
      time_sig: [4, 4],
      key_sig: 'C',
      scale: 'maj',
      ctrl_per_beat: 2,
      incomplete_measure: true,
      volumes: [110, 80]
    },
    contents: {
      melody: ':+ 3,2 1,2/3^,8/3,2 2 1 2 3 1,2/:- 6,4 3^,4/3,4 :+ 3,2 1,2/2 2^,7/2,2 1 6-,1 1 6-,1 1,2/:- 7^,8/7,4 0 :+ 3,2 1/3 3,2 3^,1 3^,4/3,2 2 1 2 3 1,2/:- 6,4 3^,4/3,6 3,2/5,2 3 5 6,2 :+ 1,2/3 2,3 1,4/:- 6^,8/6,4 :+ 3,2 1,2'.split('/'),
      harmony: "E7,4/Amin,8/Bb7,8/Amin,4 E7,4/Amin,4 A7,4/Dmin,8/F7,8/F#min7,4 B7,4/E7,8/Am,8/Bb7,8/Am,8/D7,8/C,4 Am,4/D7,4 E7,4/Am,4 D7,4/Bm7,4 E7,4".split('/'),
      texture: ":-012 012,4/:-00-21+ 01,2 2,2 3,2 2,2/:iii-00-21+ 01,2 2,2 3,2 2,2/:-012 012,4 :-012 012,4/:-012 012,4 :-012 012,4/:-00-21+ 01,2 2,2 3,2 2,2/:-00-21+ 01,2 2,2 3,2 2,2/:-012 012,4 012,4/:-00-21+ 01,2 2,2 3,2 2,2/:-012 012,4 012,4/:-012 012,4 012,4/:-012 012,4 012,4/:-012 012,4 012,4/:-012 012,4 :-012 012,4/:-012 012,4 :-012 012,4/:-012 012,4 :-012 012,4/:-012 012,4 :-012 012,4".split('/')
    }
  };

  this.gen_modes = ['random', 'transpose', 'chord', 'reverse', 'sequence'];

  this.schema_summer = MG.schema_summer = {
    blocks: (function(a, b) {
      var res;
      res = {};
      a.split('/').forEach(function(e, i) {
        return res[e] = b[i];
      });
      return res;
    })('c/A/B/Br/C', [4, 32, 16, 16, 28]),
    structure: "c/A/B/Br/A/C/c".split('/'),
    scale: 'maj',
    funcs: {
      'A': "1,8/4,8/1,4 2,4/1,8".split('/'),
      'B': "4,8/6,8".split('/'),
      'Br': "2,4 5,4/5,8".split('/'),
      'C': "3,4 1,4/2,4 5,4/1,4 2,4/2,4".split('/'),
      'c': "5,4"
    },
    seeds: {
      's1': {
        dur: 4,
        choices: '1 1 1 1/2 1 1/1 1 2/1 2 1/1 3/3 1/2 2/4'.split('/').map(function(e) {
          return e.split(/\s+/).map(function(e2) {
            return parseInt(e2);
          });
        }),
        weights: [2, 3, 3, 5, 1, 3, 2, 1]
      },
      's2': {
        weights: [1, 1, 2, 5, 12, 6, 8, 4, 7, 12, 8, 3, 1, 0, 1],
        choices: (function() {
          return Array(15).fill().map(function(e, i) {
            return i - 7;
          });
        })()
      }
    },
    melody: {
      'c': {
        mode: 'random',
        options: {
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      },
      'A': {
        mode: 'random',
        options: {
          chords: ["Amin,8", "Bb7,8", "Amin,4 E7,4", "Amin,4 A7,4"],
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      },
      'B': {
        mode: 'transpose',
        options: {
          src: "A",
          offset: 0,
          scale: 'maj',
          interval: 4
        }
      },
      'Br': {
        mode: 'reverse',
        options: {
          src: 'B',
          deep: 'false'
        }
      },
      'C': {
        mode: 'chord',
        options: {
          chords: "C,4 Am,4/D7,4 E7,4/Am,4 D7,4/Bm7,4".split('/'),
          rhythm: {
            seed: 's1'
          },
          interval: {
            chromatic: false,
            seed: 's2'
          }
        }
      }
    }
  };

  this.MG = MG;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MG;
  }

}).call(this);

//# sourceMappingURL=musical.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var Analyzer, MG, ref;

  MG = (ref = this.MG) != null ? ref : {};

  Analyzer = (function() {
    function Analyzer(key_sig, scale_name) {
      this.key_sig = key_sig;
      this.scale_name = scale_name;
      this.scale = MG.scale_class[this.scale_name];
      this.key_ref = MG.key_class[this.key_sig];
      this.toScale = MG.pitchToScale(this.scale_name, this.key_sig);
      this.key_sig_acc = MG.key_sig[this.key_sig];
    }

    Analyzer.prototype.pitch_info = function(pitch, chord) {
      var i, info, key, p, ref1, sharp, tmp;
      info = {};
      if (chord != null) {
        if (typeof chord === 'string') {
          chord = MG.getChords(chord, 3);
        }
        info.isChordTone = false;
        ref1 = chord[1];
        for (i in ref1) {
          p = ref1[i];
          if ((chord[0] + p - pitch) % 12 === 0) {
            info.isChordTone = true;
            break;
          }
        }
      }
      tmp = this.toScale(pitch);
      info.inScale = tmp[2] === 0;
      key = MG.scale_keys[s.key_sig][tmp[0]];
      sharp = MG.key_sig[this.key_sig] >= 0;
      info.keyName = info.inScale ? [
        key, Math.floor(pitch / 12) - ({
          'Cb': 0,
          'B#': 2
        }[key] || 1)
      ] : MG.pitchToKey(pitch, sharp);
      return info;
    };

    return Analyzer;

  })();

  MG.Analyzer = Analyzer;

}).call(this);

//# sourceMappingURL=Analyzer.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG;

  MG = ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null) && require('./musical')) || this.MG;

  this.AppMG = (function() {
    function AppMG(ui, options) {
      if (options != null) {
        this.schema = options.schema, this.settings = options.settings, this.contents = options.contents;
      } else {
        this.schema = Object.assign({}, MG.schema_summer);
        this.settings = Object.assign({}, MG.score_summer.settings);
        this.contents = Object.assign({}, MG.score_summer.contents);
      }
      if (ui != null) {
        this.editor = ui.editor, this.renderer = ui.renderer, this.player = ui.player, this.playbtns = ui.playbtns;
      }
      return;
    }

    AppMG.prototype["export"] = function() {
      return {
        settings: this.settings,
        schema: this.schema,
        contents: this.contents
      };
    };

    AppMG.prototype.updateEditor = function() {
      ['melody', 'harmony', 'texture'].forEach((function(_this) {
        return function(e) {
          _this.editor[e].setValue(_this.contents[e].join('\n'), -1);
        };
      })(this));
      this.editor.score.setValue(JSON.stringify(this.settings, null, 2), -1);
      this.editor.schema.setValue(JSON.stringify(this.schema, null, 2), -1);
    };

    AppMG.prototype.play = function(n) {
      if (!this.player.playing[n]) {
        this.player.play(n);
      } else {
        this.player.pause(n);
      }
      return this.playbtns[n].toggleClass('glyphicon-play glyphicon-pause');
    };

    AppMG.prototype.parse = function() {
      var e, error;
      try {
        this.settings = JSON.parse(this.editor.score.getValue());
      } catch (error) {
        e = error;
        $.notify('Bad score format!', 'warning');
      }
      ['melody', 'harmony', 'texture'].forEach((function(_this) {
        return function(e) {
          return _this.contents[e] = _this.editor[e].getValue().split(/[\/\n]+/);
        };
      })(this));
      return this.player.fromScore(this.settings, this.contents);
    };

    return AppMG;

  })();

}).call(this);

//# sourceMappingURL=appMG.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, ref,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  MG = (ref = this.MG) != null ? ref : {};

  this.Generator = (function() {
    function Generator(settings, schema) {
      var base, base1;
      this.settings = settings;
      this.schema = schema;
      if ((base = this.settings).key_sig == null) {
        base.key_sig = 'C';
      }
      if ((base1 = this.settings).scale == null) {
        base1.scale = 'maj';
      }
      this.keyref = MG.keyToPitch[this.settings.key_sig + '4'];
      this.scale = MG.scale_class[this.settings.scale];
      this.seeds = this.schema.seeds;
      this.res = {};
      this.toPitch = MG.scaleToPitch(this.settings.scale, this.settings.key_sig);
      this.toScale = MG.pitchToScale(this.settings.scale, this.settings.key_sig);
    }

    Generator.prototype.generate = function() {
      var dur, i, mode, ref1;
      ref1 = this.schema.blocks;
      for (i in ref1) {
        dur = ref1[i];
        mode = this.schema.melody[i];
        switch (mode.mode) {
          case 'random':
            this.res[i] = this.gen_random(dur, mode.options);
            break;
          case 'transpose':
            this.res[i] = this.gen_transpose(dur, mode.options);
            break;
          case 'chord':
            this.res[i] = this.gen_chord(dur, mode.options);
            break;
          case 'reverse':
            this.res[i] = this.gen_reverse(mode.options);
        }
      }
      console.log(this.res, 'res');
      return this.res;
    };

    Generator.prototype.gen_transpose = function(dur, options) {
      var cur_i, interval, refd, res, src, tmp, tmp2, transpose;
      res = {
        dur: [],
        pitch: []
      };
      transpose = MG.transposer(options.scale, this.settings.key_sig);
      src = this.res[options.src];
      interval = options.interval;
      if (typeof interval === 'number') {
        interval = [interval];
      }
      refd = 0;
      cur_i = 0;
      while (dur > 0) {
        console.log(refd, src.dur.length);
        if (refd >= src.dur.length) {
          refd -= src.dur.length;
          cur_i = (cur_i + 1) % interval.length;
          console.log('shift to next interval');
        }
        tmp = [];
        tmp2 = [];
        src.dur[refd].forEach(function(e, i) {
          if (dur - e >= 0) {
            tmp.push(e);
            tmp2.push(transpose(src.pitch[refd][i], interval[cur_i]));
            dur -= e;
          } else if (dur > 0) {
            tmp.push(dur);
            tmp2.push(transpose(src.pitch[refd][i], interval[cur_i]));
            dur = 0;
          }
        });
        refd++;
        res.dur.push(tmp);
        res.pitch.push(tmp2);
      }
      return res;
    };

    Generator.prototype.gen_reverse = function(options) {
      var res, src;
      res = {
        dur: [],
        pitch: []
      };
      src = this.res[options.src];
      if ((options.deep != null) && options.deep === true) {
        res.dur = src.dur.slice().reverse().map(function(arr) {
          return arr.slice().reverse();
        });
        res.pitch = src.pitch.slice().reverse().map(function(arr) {
          return arr.slice().reverse();
        });
      } else {
        res.dur = src.dur.slice().reverse();
        res.pitch = src.pitch.slice().reverse();
      }
      console.log(res, 'reverse ' + options.src);
      return res;
    };

    Generator.prototype.gen_exact = function(options) {
      var res;
      return res = {
        dur: options.dur,
        pitch: options.pitch
      };
    };

    Generator.prototype.gen_random = function(dur, options) {
      var i, j, n, pre, rc1, rc2, res, scale_len, seed, seed2, tmp, toPitch;
      toPitch = this.toPitch;
      scale_len = this.scale.length;
      res = {
        dur: [],
        pitch: []
      };
      seed = {};
      if ((options.rhythm.seed != null) && (this.seeds != null)) {
        seed = this.seeds[options.rhythm.seed];
      } else {
        seed.dur = options.rhythm[0];
        seed.choices = options.rhythm[1];
        seed.weights = options.rhythm[2];
      }
      seed2 = {};
      if ((options.interval.seed != null) && (this.seeds != null)) {
        seed2 = this.seeds[options.interval.seed];
      } else {
        seed2 = options.interval;
      }
      n = dur / seed.dur >>> 0;
      rc1 = this.rndPicker(seed.choices, seed.weights);
      console.log(seed);
      rc2 = this.rndPicker(seed2.choices, seed2.weights);
      pre = scale_len * 4;
      i = 0;
      while (i < n) {
        res.dur.push(rc1.gen());
        tmp = [];
        j = 0;
        while (j < res.dur[i].length) {
          pre += rc2.gen() % scale_len;
          if (pre < 0) {
            pre = 0;
          }
          if (pre > scale_len * 8) {
            pre = scale_len * 8;
          }
          tmp.push(toPitch(pre));
          ++j;
        }
        res.pitch.push(tmp);
        ++i;
      }
      return res;
    };

    Generator.prototype.gen_chord = function(dur, options) {
      var chords, fix, i, ii, j, n, new_pre, pre, pre2, r, rc1, rc2, refc, refdur, res, scale_len, seed, seed2, tmp, toPitch, toScale;
      toPitch = this.toPitch;
      toScale = this.toScale;
      chords = _.flatten(ScoreObj.prototype.parseHarmony(options.chords), true);
      scale_len = this.scale.length;
      refc = 0;
      refdur = chords[refc][0];
      res = {
        dur: [],
        pitch: []
      };
      seed = {};
      if ((options.rhythm.seed != null) && (this.seeds != null)) {
        seed = this.seeds[options.rhythm.seed];
      } else {
        seed.dur = options.rhythm[0];
        seed.choices = options.rhythm[1];
        seed.weights = options.rhythm[2];
      }
      seed2 = {};
      if ((options.interval.seed != null) && (this.seeds != null)) {
        seed2 = this.seeds[options.interval.seed];
      } else {
        seed2 = options.interval;
      }
      n = dur / seed.dur >>> 0;
      rc1 = this.rndPicker(seed.choices, seed.weights);
      rc2 = this.rndPicker(seed2.choices, seed2.weights);
      pre = scale_len * 4;
      pre2 = pre;
      i = 0;
      while (i < n) {
        res.dur.push(rc1.gen());
        tmp = [];
        j = 0;
        while (j < res.dur[i].length) {
          if (Math.random() > 0.6) {
            pre += rc2.gen();
            if (pre < 0) {
              pre = 0;
            }
            if (pre > scale_len * 8) {
              pre = scale_len * 8;
            }
            tmp.push(toPitch(pre));
          } else {
            r = Math.random() * 9 >> 0;
            ii = r % 3;
            if (refc + 1 < chords.length && refdur < 0) {
              refdur += chords[++refc][0];
            }
            pre = toPitch(pre);
            new_pre = chords[refc][1] + chords[refc][2][ii] + 12 * (Math.floor(r / 3) - 1);
            while (new_pre - pre > 12) {
              new_pre -= 12;
            }
            while (pre - new_pre > 12) {
              new_pre += 12;
            }
            if (new_pre < 21) {
              new_pre = 21;
            }
            if (new_pre > 108) {
              new_pre = 108;
            }
            tmp.push(new_pre);
            fix = toScale(new_pre);
            pre = fix[0] + fix[1] * scale_len;
          }
          refdur -= options.rhythm[0];
          ++j;
        }
        res.pitch.push(tmp);
        ++i;
      }
      return res;
    };

    Generator.prototype.b2score = function(b, sec, flat) {
      var delta, dur, pitch, ret, tmp;
      dur = flat ? b.dur : _.flatten(b.dur, true);
      pitch = flat ? void 0 : _.flatten(b.pitch, true);
      ret = [];
      tmp = [];
      delta = 0;
      dur.forEach(function(e, j) {
        while (delta + e > sec) {
          tmp.push([sec - delta, pitch[j], true]);
          ret.push(tmp);
          tmp = [];
          e -= sec - delta;
          delta = 0;
        }
        tmp.push([e, pitch[j]]);
        delta += e;
        if (delta === sec) {
          ret.push(tmp);
          tmp = [];
          return delta = 0;
        }
      });
      if (tmp.length > 0) {
        ret.push(tmp);
      }
      return ret;
    };

    Generator.prototype.toScoreObj = function() {
      var b, e0, obj, ref1, res, sec;
      if (res === {}) {
        this.generate();
      }
      sec = this.settings.ctrl_per_beat * this.settings.time_sig[0];
      res = {};
      ref1 = this.res;
      for (e0 in ref1) {
        b = ref1[e0];
        res[e0] = this.b2score(b, sec);
      }
      res = this.schema.structure.map(function(e) {
        return res[e];
      });
      obj = new ScoreObj(this.settings);
      obj.setMelody(_.flatten(res, true), true);
      return obj;
    };

    Generator.prototype.rndPicker = function(choices, weights) {
      var i, k, p, ref1, s;
      s = weights.reduce((function(a, b) {
        return a + b;
      }), 0);
      p = weights.map(function(e) {
        return e / s;
      });
      s = 0;
      for (i = k = 0, ref1 = p.length; k < ref1; i = k += 1) {
        s = (p[i] += s);
      }
      return {
        gen: function() {
          var l, r, ref2;
          r = Math.random();
          for (i = l = 0, ref2 = p.length; l < ref2; i = l += 1) {
            if (r < p[i]) {
              return choices[i];
            }
          }
          return choices[p.length - 1];
        }
      };
    };

    Generator.prototype.gen_random_new = function(end_pos, states, start, constraint) {
      var cur, merge, nexts, picker, res, val;
      res = [];
      cur = {
        state: start.state,
        pos: {
          start: start.pos,
          val: start.val
        }
      };
      while (cur.pos < end_pos) {
        nexts = states[cur.state].choices.map(function(func) {
          var val, weight;
          val = func(cur.pos, cur.val);
          weight = constraint(cur.pos, cur.val, val);
          return [val, weight];
        });
        merge = _.unzip(nexts);
        picker = this.rndPicker(merge[0], merge[1]);
        val = picker.gen();
        if (cur.pos + val.dur >= end_pos) {
          val.dur = end_pos - cur.pos;
        }
        cur.state = states.transition(cur.pos, val);
        cur.pos += val.dur;
        cur.val = val;
        res.push(val);
      }
      return res;
    };

    Generator.prototype.sample_start = {
      state: 'start',
      pos: 0,
      val: {
        dur: 2,
        val: 60,
        weight: []
      }
    };

    Generator.prototype.sample_states = {
      transition: function(pos, val) {},
      'start': {
        choices: function(pos, val) {}
      },
      'middle': {
        choices: function(pos, val) {}
      },
      'other': {
        choices: function(pos, val) {}
      }
    };

    Generator.prototype.sample_constraint = function(pos, preval, val) {
      var weights;
      weights = [4, 2, 4, 6, 6, 8, 1, 8, 6, 6, 2, 2];
      return weights[modulo(val.val - preval.val, 12)];
    };

    return Generator;

  })();

}).call(this);

//# sourceMappingURL=Generator.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  var MG, ref1;

  MG = (ref1 = this.MG) != null ? ref1 : {};

  this.ScoreObj = (function() {
    function ScoreObj(options, contents) {
      if (options == null) {
        options = {};
      }
      this.tempo = options.tempo, this.time_sig = options.time_sig, this.key_sig = options.key_sig, this.ctrl_per_beat = options.ctrl_per_beat, this.scale = options.scale, this.volumes = options.volumes;
      if (this.tempo == null) {
        this.tempo = 120;
      }
      if (this.time_sig == null) {
        this.time_sig = [4, 4];
      }
      if (this.key_sig == null) {
        this.key_sig = 'C';
      }
      if (this.ctrl_per_beat == null) {
        this.ctrl_per_beat = 4;
      }
      if (this.scale == null) {
        this.scale = 'maj';
      }
      if (this.volumes == null) {
        this.volumes = [110, 80];
      }
      this.init_ref = MG.scaleToPitch(this.scale, this.key_sig)(4 * MG.scale_class[this.scale].length);
      this.init_ctrlTicks = (60000.0 / this.tempo / this.ctrl_per_beat) >>> 0;
      this.tracks = [];
      this.harmony = [];
      if (contents != null) {
        this.parse(contents);
      }
    }

    ScoreObj.prototype.getSettings = function() {
      return {
        tempo: this.tempo,
        time_sig: this.time_sig,
        key_sig: this.key_sig,
        ctrl_per_beat: this.ctrl_per_beat,
        scale: this.scale,
        volumes: this.volumes
      };
    };

    ScoreObj.prototype.setMelody = function(melody, parsed) {
      return this.tracks[0] = (parsed != null) && parsed === true ? melody : this.parseMelody(melody, MG.scale_class[this.scale], this.init_ref);
    };

    ScoreObj.prototype.setTexture = function(texture, harmony, parsed) {
      if ((parsed != null) && parsed === true) {
        this.harmony = harmony;
        return this.tracks[1] = texture;
      } else {
        this.harmony = this.parseHarmony(harmony);
        return this.tracks[1] = this.parseTexture(texture, this.harmony);
      }
    };

    ScoreObj.prototype.parse = function(options) {
      if (options.melody != null) {
        this.setMelody(options.melody, false);
      }
      if ((options.harmony != null) && options.texture) {
        return this.setTexture(options.texture, options.harmony);
      }
    };

    ScoreObj.prototype.pre_processing = function(text) {
      var ex;
      return ex = /\/\/[^\n][\n]+|[\/\n]]/;
    };

    ScoreObj.prototype.parseMelody = function(m, scale, init_ref) {
      var ref, res;
      if (typeof m === 'undefined') {
        console.log('empty melody');
        return;
      }
      if (scale == null) {
        scale = MG.scale_class['maj'];
      }
      if (init_ref == null) {
        init_ref = 60;
      }
      ref = init_ref;
      res = m.map((function(_this) {
        return function(e) {
          var measure, notes;
          notes = e.trim().split(/\s+/);
          measure = [];
          notes.forEach(function(e2) {
            var dur, e3, pitches, ref2, terms, tied;
            if (e2[0] === ':') {
              switch (e2[1]) {
                case '+':
                  ref += 12;
                  break;
                case '-':
                  ref -= 12;
                  break;
                default:
                  ref = init_ref;
              }
            } else {
              tied = false;
              terms = e2.split(',');
              pitches = [];
              e3 = '';
              Array.prototype.forEach.call(terms[0], function(to) {
                e3 += to;
                switch (e3) {
                  case '0':
                    pitches.push(0);
                    break;
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                    if (e3 > scale.length) {
                      console.log('Exceed scale length ' + e3);
                      e3 = scale.length;
                    }
                    pitches.push(ref + scale[e3 - '1']);
                    break;
                  case 'x':
                  case 'y':
                  case 'z':
                    e3 = {
                      'x': 10,
                      'y': 11,
                      'z': 12
                    }[e3];
                    if (e3 > scale.length) {
                      console.log('Exceed scale length ' + e3);
                      e3 = scale.length;
                    }
                    pitches.push(ref + scale[e3 - '1']);
                    break;
                  case '+':
                  case '-':
                  case '#':
                  case 'b':
                    pitches[pitches.length - 1] += {
                      '+': 12,
                      '-': -12,
                      '#': 1,
                      'b': -1
                    }[e3];
                    break;
                  case '^':
                    tied = true;
                    break;
                  default:
                    console.log('skip invalid flag ' + e3);
                }
                return e3 = '';
              });
              dur = terms.length >= 2 ? (ref2 = parseInt(terms[1])) != null ? ref2 : 1 : 1;
              if (tied) {
                measure.push([dur, pitches, true]);
              } else {
                measure.push([dur, pitches]);
              }
            }
          });
          return measure;
        };
      })(this));
      return res;
    };

    ScoreObj.prototype.parseHarmony = function(measures) {
      if (typeof measures === 'undefined') {
        console.log('empty harmony');
        return;
      }
      return measures.map(function(e) {
        return e.trim().split(/\s+/).map(function(e2) {
          var chord_info, dur, terms;
          terms = e2.split(',');
          chord_info = MG.getChords(terms[0], 3);
          dur = terms.length >= 2 ? parseInt(terms[1]) : 1;
          return [dur, chord_info[0], chord_info[1]];
        });
      });
    };

    ScoreObj.prototype.parseTexture = function(measures, harmony) {
      var c, delta, refc, refi, res;
      if (typeof measures === 'undefined' || typeof harmony === 'undefined') {
        console.log('empty texture');
        return;
      }
      c = _.flatten(harmony, true);
      delta = 0;
      refc = [];
      refi = -1;
      res = measures.map(function(e) {
        var arrange, measure;
        measure = [];
        arrange = e.trim().split(/\s+/);
        arrange.forEach(function(e2) {
          var bass, chord, dur, e3, inv, j, k, n, ref2, ref3, ref4, ref5, refk, results, s, terms, tied, tmp;
          if (e2[0] === ':') {
            refk = MG.keyToPitch('C3');
            while (refi < c.length && delta >= 0) {
              delta -= c[++refi][0];
            }
            inv = /:i*/.exec(e2)[0].length - 1;
            bass = (c[refi][1] + c[refi][2][inv]) % 12;
            chord = MG.inverted(c[refi][2], inv);
            inv += 1;
            while ((ref2 = e2[inv]) === '+' || ref2 === '-') {
              refk += {
                '+': 12,
                '-': -12
              }[e2[inv++]];
            }
            bass += refk;
            refc = [];
            results = [];
            for (j = k = ref3 = inv, ref4 = e2.length; k < ref4; j = k += 1) {
              switch (s = e2[j]) {
                case '0':
                case '1':
                case '2':
                case '3':
                  results.push(refc.push(bass + chord[parseInt(s)]));
                  break;
                case '+':
                case '-':
                case '#':
                case 'b':
                  results.push(refc[refc.length - 1] += {
                    '+': 12,
                    '-': -12,
                    '#': 1,
                    'b': -1
                  }[s]);
                  break;
                default:
                  results.push(console.log('skip unknown config ' + s));
              }
            }
            return results;
          } else {
            tied = false;
            terms = e2.split(',');
            dur = terms.length >= (2 != null) ? parseInt(terms[1]) : 1;
            tmp = [];
            for (j = n = 0, ref5 = terms[0].length; n < ref5; j = n += 1) {
              e3 = terms[0][j];
              if (e3 === '^') {
                tied = true;
              } else if (refc[e3]) {
                tmp.push(refc[e3]);
              } else {
                console.log('invalid texture ' + e3);
              }
            }
            measure.push(tied ? [dur, tmp, true] : [dur, tmp]);
            return delta += dur;
          }
        });
        return measure;
      });
      return res;
    };

    ScoreObj.prototype.toText = function(m) {
      var ref_oct, res, toScale;
      console.log('to score text');
      if (m == null) {
        m = this.tracks[0];
      }
      if (m == null) {
        console.log('null melody');
        return;
      }
      toScale = MG.pitchToScale(this.scale, this.key_sig);
      ref_oct = 4;
      res = m.map(function(e) {
        var ret;
        ret = [];
        e.forEach(function(e1) {
          var o;
          o = '';
          if (typeof e1[1] === 'number') {
            e1[1] = [e1[1]];
          }
          e1[1].forEach(function(e2) {
            var diff, tmp;
            if (e2 < 21 || e2 > 108) {
              return o += '0';
            } else {
              tmp = toScale(e2);
              diff = tmp[1] - ref_oct;
              if (diff < -1 || diff > 1) {
                o += ':';
                while (diff < -1) {
                  o += '-';
                  ref_oct--;
                  diff++;
                }
                while (diff > 1) {
                  o += '+';
                  ref_oct++;
                  diff--;
                }
                o += ' ';
              }
              o += 1 + tmp[0];
              o += {
                '-1': '-',
                1: '+'
              }[diff] || '';
              return o += {
                1: '#',
                2: '##'
              }[tmp[2]] || '';
            }
          });
          if (e1[2] === true) {
            o += '^';
          }
          if (e1[0] > 1) {
            o += ',' + e1[0];
          }
          return ret.push(o);
        });
        return ret.join(' ');
      });
      return res;
    };

    ScoreObj.prototype.toMidi = function() {
      var ctrlTicks, delta, dur, e, i, l, m, q, t, vol;
      console.log('to midi');
      ctrlTicks = this.init_ctrlTicks;
      q = _.flatten(this.tracks[0], true);
      t = this.tracks[1] ? _.flatten(this.tracks[1], true) : null;
      m = new simpMidi();
      delta = 0;
      vol = this.volumes[0];
      i = 0;
      while (i < q.length) {
        e = q[i];
        if (typeof e[1] === 'number' && e[1] < 21 && e[1] > 108) {
          delta += e[0];
        } else {
          dur = e[0];
          while (q[i][2] === true && i + 1 < q.length) {
            dur += q[++i][0];
          }
          m.addNotes(1, dur * ctrlTicks, q[i][1], vol, 0, delta * ctrlTicks);
          delta = 0;
        }
        ++i;
      }
      m.setTimeSignature.apply(m, this.time_sig);
      m.setKeySignature(MG.key_sig[this.key_sig], 'maj');
      m.setTempo(this.tempo);
      if (t === null) {
        m.finish();
        return m;
      }
      vol = this.volumes[1];
      l = m.addTrack() - 1;
      m.addEvent(l, 0, 'programChange', l - 1, 0);
      t.forEach(function(e) {
        return m.addNotes(l, e[0] * ctrlTicks, e[1], vol);
      });
      m.finish();
      return m;
    };

    return ScoreObj;

  })();

}).call(this);

//# sourceMappingURL=ScoreObj.js.map
;// Generated by CoffeeScript 1.10.0
(function() {
  this.ScoreRenderer = (function() {
    var dur_mapper;

    function ScoreRenderer(c, p) {
      var pager;
      this.c = document.getElementById(c);
      this.real_ctx = this.c.getContext('2d');
      this.hidden_canvas = document.createElement('canvas');
      this.r = new Vex.Flow.Renderer(this.hidden_canvas, Vex.Flow.Renderer.Backends.CANVAS);
      this.ctx = this.r.getContext();
      this.geo = {
        system_width: 900,
        system_height: 80,
        system_interval: 30,
        left_padding: 25,
        top_padding: 20,
        reserved_width: 55
      };
      this.layout = {
        measure_per_system: 4,
        system_per_page: 6
      };
      this.numPage = 1;
      this.currentPage = 1;
      this.measures = [];
      this.pages = [];
      pager = $('#midi_pager');
      this.UI = {
        prev: pager.find('.prev'),
        next: pager.find('.next'),
        page_num: pager.find('.page_num'),
        page_count: pager.find('.page_count')
      };
      this.UI.prev.on('click', (function(_this) {
        return function() {
          if (_this.currentPage <= 1) {
            return;
          }
          _this.currentPage--;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      this.UI.next.on('click', (function(_this) {
        return function() {
          if (_this.currentPage >= _this.numPage) {
            return;
          }
          _this.currentPage++;
          return _this.renderPage(_this.currentPage - 1);
        };
      })(this));
      if (p != null) {
        this.p = new fabric.StaticCanvas(p, {
          width: $('.canvas-wrapper').width(),
          height: $('.canvas-wrapper').height(),
          backgroundColor: 'rgba(240,250,240, 5)'
        });
      }
    }

    ScoreRenderer.prototype.newStave = function(m, k) {
      var i, j, w, x, y;
      i = m % this.layout.measure_per_system;
      j = (Math.floor(m / this.layout.measure_per_system)) % this.layout.system_per_page;
      w = Math.floor((this.geo.system_width - this.geo.reserved_width) / this.layout.measure_per_system);
      x = this.geo.left_padding + i * w;
      y = this.geo.top_padding + j * (this.geo.system_height + this.geo.system_interval);
      if (i === 0) {
        return new Vex.Flow.Stave(x, y, w + this.geo.reserved_width).addClef('treble').addKeySignature(k);
      } else {
        x += this.geo.reserved_width;
        return new Vex.Flow.Stave(x, y, w);
      }
    };

    dur_mapper = ["16", "8", "8d", "4", "4", "4d", "4dd", "2", "2", "2", "2", "2d", "2d", "2dd", "2ddd", "1"];

    ScoreRenderer.prototype.dur_map = function(dur) {
      dur = (dur * 4) >>> 0;
      return dur_mapper[dur - 1];
    };

    ScoreRenderer.prototype.renderPage = function(num) {
      var c, ctx, e, i, l, last, ref, ref1, start;
      if (num < 0 || num >= this.numPage) {
        return;
      }
      if (this.pages[num] != null) {
        this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
        this.real_ctx.drawImage(this.pages[num], 0, 0);
        this.UI.page_num.html(num + 1);
        return;
      }
      console.log('render page', num + 1);
      this.r.resize(1000, 800);
      this.c.width = 1000;
      this.c.height = 800;
      start = this.layout.measure_per_system * this.layout.system_per_page;
      last = (num + 1) * start;
      start = last - start;
      if (last >= this.measures.length) {
        last = this.measures.length;
      }
      ctx = this.ctx;
      for (i = l = ref = start, ref1 = last; l < ref1; i = l += 1) {
        e = this.measures[i];
        e.stave.setContext(ctx).draw();
        e.voices.forEach(function(v) {
          return v.draw(ctx, e.stave);
        });
        e.beams.forEach(function(v) {
          return v.setContext(ctx).draw();
        });
      }
      c = document.createElement('canvas');
      c.width = 1000;
      c.height = 800;
      c.getContext('2d').drawImage(this.hidden_canvas, 0, 0);
      this.pages[num] = c;
      this.real_ctx.clearRect(0, 0, this.c.width, this.c.height);
      this.real_ctx.drawImage(this.pages[num], 0, 0);
      return this.UI.page_num.html(num + 1);
    };

    ScoreRenderer.prototype.render = function(score, contents) {
      var beams, dur_tot, formatter, i, l, melody, notes, num_beats, raw_w, ref, s, sharp, stave, toScale, voice, w;
      raw_w = Math.floor((this.geo.system_width - this.geo.reserved_width) / this.layout.measure_per_system);
      s = this.s = new ScoreObj(score, contents);
      sharp = MG.key_sig[score.key_sig] >= 0;
      toScale = MG.pitchToScale(score.scale, s.key_sig);
      this.measures = [];
      melody = s.tracks[0];
      for (i = l = 0, ref = melody.length; l < ref; i = l += 1) {
        stave = this.newStave(i, s.key_sig);
        if (i === 0) {
          stave.addTimeSignature(s.time_sig.join('/'));
        }
        dur_tot = 0;
        notes = melody[i].map((function(_this) {
          return function(e) {
            var duration, keys, res;
            dur_tot += e[0];
            duration = _this.dur_map(e[0] / s.ctrl_per_beat);
            keys = [];
            if (typeof e[1] === 'number') {
              e[1] = [e[1]];
            }
            e[1].forEach(function(e1) {
              var key, tmp;
              if (e1 < 21 || e1 > 108) {
                return;
              }
              tmp = toScale(e1);
              key = MG.scale_keys[s.key_sig][tmp[0]];
              key += '/' + ((Math.floor(e1 / 12)) - 1 + ({
                'Cb': 1,
                'B#': -1
              }[key] || 0));
              if (tmp[2] !== 0) {
                key = MG.pitchToKey(e1, sharp).join('/');
              }
              if (key != null) {
                return keys.push(key);
              }
            });
            if (keys.length <= 0) {
              keys.push('Bb/4');
              duration += 'r';
            }
            res = new Vex.Flow.StaveNote({
              keys: keys,
              duration: duration,
              auto_stem: true
            });
            if (duration.substr(-1) === 'd') {
              res.addDotToAll();
              if (duration.substr(-2, 1) === 'd') {
                res.addDotToAll();
              }
            }
            return res;
          };
        })(this));
        num_beats = Math.floor(dur_tot / s.ctrl_per_beat);
        voice = new Vex.Flow.Voice({
          num_beats: num_beats,
          beat_value: s.time_sig[1],
          resolution: Vex.Flow.RESOLUTION
        });
        voice.addTickables(notes);
        Vex.Flow.Accidental.applyAccidentals([voice], s.key_sig);
        beams = Vex.Flow.Beam.applyAndGetBeams(voice);
        w = raw_w;
        if (i % this.layout.measure_per_system === 0) {
          w -= this.geo.reserved_width;
        }
        if (i === 0) {
          w -= 10;
        }
        formatter = new Vex.Flow.Formatter().joinVoices([voice]).format([voice], w - 10);
        this.measures.push({
          voices: [voice],
          stave: stave,
          beams: beams
        });
      }
      this.numPage = Math.ceil(this.measures.length / this.layout.measure_per_system / this.layout.system_per_page);
      this.UI.page_count.html(this.numPage);
      this.currentPage = 1;
      this.pages.forEach((function(_this) {
        return function(c, i) {
          return delete _this.pages[i];
        };
      })(this));
      this.pages = [];
      return this.renderPage(this.currentPage - 1);
    };

    return ScoreRenderer;

  })();

}).call(this);

//# sourceMappingURL=ScoreRenderer.js.map
;function dataURLtoBlob(dataurl) {
	var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
			bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
	while(n--){
		u8arr[n] = bstr.charCodeAt(n);
	}
	return new Blob([u8arr], {type:mime});
}
var seqPlayer = {
	channel:0,
	harmony:[],
	tracks: [],
	playing:[],
	cur_i:[],
	midi: null,
	raw_midi: "",
	play:function(n){
		n = n || 0;
		if(!this.tracks[n] || this.tracks[n].length<=0){
			return;
		}
		this.playing[n] = true;
		var q = this.tracks[n];
		var nexti = this.cur_i[n];

		var cur = q[nexti];
		nexti++;
		var channel = this.channel;

		function loop(){
			if(cur[0]>0){ // not tied
				var notes = typeof cur[1] == 'number'? [cur[1]] : cur[1];
				notes.forEach(function(e){
					if(e>=21 && e<=108) {
						MIDI.noteOn(channel, e, cur[2]);
					}
				});
			}
        	setTimeout(function(){
				var notes = typeof cur[1] == 'number'? [cur[1]] : cur[1];
        		if(nexti < 0){

					notes.forEach(function(e){
						if(e>=21 && e<=108){
							MIDI.noteOff(channel,e);
						}
					});

        			seqPlayer.playing[n] = false;
        			seqPlayer.onend(n);
        		}else{

        			if(q[nexti][0]>0){
						notes.forEach(function(e){
							if(e>=21 && e<= 108){
								MIDI.noteOff(channel,e);
							}
						});

        		    }
        		    cur = q[nexti];
					if(seqPlayer.playing[n]){
						nexti++;
						if(nexti>= q.length){
							nexti = -1;
							seqPlayer.cur_i[n] = 0;
						}
					}else{
						seqPlayer.cur_i[n] = nexti;
						nexti = -1;
					}
        		    //log('next',q[nexti]);
        		    loop();
        	    }
        	},cur[0]>=0? cur[0]: -cur[0]);
				

	    }
	    setTimeout(loop, 0);



	},
	toQ: function(arr, ctrlTicks, vol){
		var vol = vol || 110;
		var m = _.flatten(arr, true);
		var res = [];
		for (var j = 0; j < m.length; ++j) {
			var delta = m[j][0];
			while (m[j][2] == true && j + 1 < m.length) {
				j++;
				delta += m[j][0];
			}
			res.push([delta * ctrlTicks, m[j][1], vol])
		}
		return res;

	},
	pause:function(n){
		var n = n || 0;
		if(n >= this.tracks.length){
			return;
		}
		this.playing[n] = false;

	},
	stop:function(n){
		var n = n || 0;
		if(n >= this.tracks.length){
			return;
		}
		this.playing[n] = false;
		this.cur_i[n] = 0;

	},
	onend:function(){},
    fromScore:function (src, contents) {
        var obj = new ScoreObj(src,contents);
		var ctrlTicks = obj.init_ctrlTicks;
		// TODO: add volume control
		var q = this.toQ(obj.tracks[0], ctrlTicks, src.volumes[0]);
		var t = this.toQ(obj.tracks[1], ctrlTicks, src.volumes[1]);
		this.tracks = [];
		this.tracks.push(q, t);
		this.playing = [false, false];
		this.cur_i = [0,0];
        this.harmony = obj.harmony;
        this.midi = obj.toMidi();
        this.raw_midi = MidiWriter(this.midi);

    },
	saveMidi:function(){
		if(this.raw_midi.length<1) return;
		var bf = new Uint8Array(this.raw_midi.split("").map(function(e){return e.charCodeAt(0);}));
		saveAs(new File([bf], 'sample.mid', {type:"audio/midi"}));
	}
}



var TEST = TEST || {};



TEST.analysis = function(data, ctrl_per_beat){
	var data = data || MIDI.Player.currentData;
	var ctrl_per_beat = ctrl_per_beat || 4;
	var m = MidiFile(data);
	var q = simpMidi.prototype.quantize.call(m, ctrl_per_beat);

	var tracks =  q.map(function(track){
		var res = [];
		var tmp = [];
		// handle
		var delta = 0;
		track.forEach(function(e){
			if(e[0]>delta){
				if(tmp.length>0){
					res.push([e[0]-delta, tmp]);
					tmp = [];
				}else{
					res.push([e[0]-delta, [0]]);//rest
				}
				delta = e[0];
			}else{
				// ignore 'noteOff' and velocity == 0
				if(e[1] == 'noteOn' && e[3] != 0){
					tmp.push(e[2]); //noteNumber
				}
			}
		});
		res = _.unzip(res);
		res = {dur:res[0], pitch:res[1]};
		return Generator.prototype.b2score.call({},res,ctrl_per_beat);
	});
	var info =  tracks.map(function(e){
		return midi_statistics(e);
	});

	return info;
};

function midi_statistics(obj){
	function obj_sort(data){
		var k = Object.keys(data);
		var v = k.map(function(key){return data[key]});
		var kv = _.zip(k,v);
		kv.sort(function(a,b){return b[1]-a[1]});// decending
		return kv;
	}
	var info = {rhythm:{}, melody:{one:{}, two:{}}};
	var one = {}, two = {};
	var n_one = 0, n_two = 0;
	obj.forEach(function(e){
		var measure = _.unzip(e);
		var r = measure[0];
		info.rhythm[r] = 1+ (info.rhythm[r] || 0);
		r = measure[1];
		if(r.length<2) return;
		var c = [r[0] % 12, (r[1]-r[0])%12];
		one[c] = 1+ (one[c] || 0); n_one ++;
		for(var i=2;i < r.length;++i){
			c = [r[i-1]%12, (r[i]-r[i-1])%12];
			one[c] = 1 + (one[c]||0); n_one ++;
			c = [r[i-2] % 12, (r[i-1] - r[i-2]) % 12, c[1]];
			two[c] = 1 + (two[c]||0); n_two ++;
		}
	});

	info = {
		rhythm: obj_sort(info.rhythm),
		melody: {
			one: obj_sort(one),
			two: obj_sort(two),
			n: [0,n_one, n_two]
		}
	};
	return info;


}



    





